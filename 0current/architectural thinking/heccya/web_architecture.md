# TODO

move this into 0heccya

<https://en.wikipedia.org/wiki/Client%E2%80%93server_model>
<https://developer.mozilla.org/en-US/docs/Web/HTTP>
<https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages>
<https://en.wikipedia.org/wiki/Web_cache>

# Links

- [CORS @mdn](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)
- [http overview @ mdn](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview)
- [http @ mdn](https://developer.mozilla.org/en-US/docs/Web/HTTP)
- [application layer @ mdn](https://en.wikipedia.org/wiki/Application_layer)
- [absraction layer @wikipedia](https://en.wikipedia.org/wiki/Abstraction_layer)
- [separation of concerns](https://en.wikipedia.org/wiki/Separation_of_concerns)
- [interoperability](https://en.wikipedia.org/wiki/Interoperability)
- [cross platform software](https://en.wikipedia.org/wiki/Cross-platform)
- [communication protocol](https://en.wikipedia.org/wiki/Communication_protocol)
- [interface](<https://en.wikipedia.org/wiki/Interface_(computing)>)
- [computer network](https://en.wikipedia.org/wiki/Computer_network) -[internet protocol suite](https://en.wikipedia.org/wiki/Internet_protocol_suite)
- [transmission control protocol](https://en.wikipedia.org/wiki/Transmission_Control_Protocol)
- [world wide web](https://en.wikipedia.org/wiki/World_Wide_Web)
- [url](https://en.wikipedia.org/wiki/URL)
- [the internet](https://en.wikipedia.org/wiki/Internet)
- [remote administration](https://en.wikipedia.org/wiki/Remote_administration)
- [file transfer](https://en.wikipedia.org/wiki/File_transfer)
- [internet protocol](https://en.wikipedia.org/wiki/Internet_Protocol)
- [client server model](https://en.wikipedia.org/wiki/Client%E2%80%93server_model)
- [stateless protocol](https://en.wikipedia.org/wiki/Stateless_protocol)
- [transport layer](https://en.wikipedia.org/wiki/Transport_layer)
- [host network](<https://en.wikipedia.org/wiki/Host_(network)>)
- [network address](https://en.wikipedia.org/wiki/Network_address)
- [web server](https://en.wikipedia.org/wiki/Web_server)
- [file server](https://en.wikipedia.org/wiki/File_server)
- [inter server](https://en.wikipedia.org/wiki/Inter-server)
- [domain name system](https://en.wikipedia.org/wiki/Domain_Name_System)
- [dynamic host configuration protocol DHCP](https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol)
- [router](<https://en.wikipedia.org/wiki/Router_(computing)>))
- [residential gateway](https://en.wikipedia.org/wiki/Residential_gateway)
- [local area network](https://en.wikipedia.org/wiki/Local_area_network)
- [wide area network](https://en.wikipedia.org/wiki/Wide_area_network)
- [request response](https://en.wikipedia.org/wiki/Request%E2%80%93response)
- [messaging pattern](https://en.wikipedia.org/wiki/Messaging_pattern)
- [application programming interface](https://en.wikipedia.org/wiki/Application_programming_interface)
- [message queue](https://en.wikipedia.org/wiki/Message_queue)
- [push technology](https://en.wikipedia.org/wiki/Push_technology)
- [hyper text transfer protocol HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol)
- [http2](https://en.wikipedia.org/wiki/HTTP/2)
- [application layer protocol negotiation](https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation)
- [transport layer security](https://en.wikipedia.org/wiki/Transport_Layer_Security#TLS_1.2)
- [user agent](https://en.wikipedia.org/wiki/User_agent)
- [web cache server](https://en.wikipedia.org/wiki/Web_cache)
- [proxy server](https://en.wikipedia.org/wiki/Proxy_server)
- [upstream server](https://en.wikipedia.org/wiki/Upstream_server)
- [http headers](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields)
- [anatomy of a simple http transaction](https://www.juniper.net/documentation/en_US/webapp5.5/topics/concepts/w-a-s-http-request-response-flow.html)
- [sync and async http requests](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Synchronous_and_Asynchronous_Requests)
- [rendering a webpage step by step](https://friendlybit.com/css/rendering-a-web-page-step-by-step/)
- [document loading and DOM lifecycle events](http://www.breck-mckye.com/blog/2014/04/document-loading-and-DOM-lifecycle-events/)
- [http fundamentals](https://gist.github.com/alyssaq/6388253)
- [http messages](https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages)
- [http cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies)

## APIs

- [send beacon](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon)
  - useful for window.onunload and window.onbeforeunload event listeners typically for sending analytics (e.g. log data)

# MUST DO

- <https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching>
- <https://www.w3.org/2005/MWI/BPWG/techs/CachingWithETag.html>
- <https://devcenter.heroku.com/articles/increasing-application-performance-with-http-cache-headers>
- <https://classroom.udacity.com/courses/ud884/lessons/1464158641/concepts/14734291220923>#
- <https://en.wikipedia.org/wiki/Tim_Berners-Lee>
- <https://www.w3.org/People/Berners-Lee/>
- <https://www.ted.com/speakers/tim_berners_lee>
- <https://en.wikipedia.org/wiki/Standard_Generalized_Markup_Language>
- <https://en.wikipedia.org/wiki/HTML>
- <http://www.restapitutorial.com/lessons/httpmethods.html>
- <https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch>
- <https://developers.google.com/web/updates/2015/03/introduction-to-fetch?hl=en>
- <http://nc110.sourceforge.net/>
- <https://en.wikipedia.org/wiki/Netcat>
- <https://badssl.com/>
- <https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content>
- <https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content/How_to_fix_website_with_mixed_content>
- <http://httparchive.org/trends.php?s=All&minlabel=Nov+15+2010&maxlabel=May+15+2016>
- <http://dev.chromium.org/spdy/spdy-whitepaper>
- <https://http2.github.io/http2-spec/compression.html>
- <https://www.w3.org/Security/wiki/Same_Origin_Policy>
- <https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#Preflighted_requests>
- <https://en.wikipedia.org/wiki/Cross-site_scripting>

# related Terminology

- separation of concerns: a design principle for separating a computer program into distinct sections, such that each section addresses a separate concern
  - concern: a set of information that affects the code of a computer program
- interoperability: a characteristic of a product or system, whose interfaces are completely understood, to work with other products or systems, at present or future, in either implementation or access, without any restrictions
- cross-platform software: computer software that is implemented on multiple computing platforms
- communication protocol: a system of rules that allow two or more entities of a communications system to transmit information via any kind of variation of a physical quantity. the protocol defines the communication in terms of:
  - syntax
  - semantics
  - syncrhonization
- interface: a shared boundary across which two/more separate components of a computer system exchange information
- computer/data network: digital telecommunications network which allows nodes to share resources
  - networked computing devices exchange data with each other using a data link
  - the connections between nodes are established using cable/wireless media
- message queue: software-engineering components used for inter-process communication, or for inter-thread communication within the same process

# terminology

- application layer: is an abstraction layer that specifies the shared protocols and interface methods used by hosts in a communication network
- abstraction layer/level: a way of hiding the implementation details of a particular set of functionality, allowing the separation of concerns to facilitate interoperability and platform independence
- internet protocol suite: the conceptual model and set of communications protocols used on the internet and similar computer networks
  - commonly known as TCP/iP becuase the foundational protocols in the suite are the transmission control protocol (tcp) and the internet protocol(ip)
- Transmission control protocol: one of the main protocols of the internet protocol suite. provides reliable, ordered, and error-checked delivery of a stream of octets between applications running on hosts communicating by an ip networkcopcopmutercopmutermutercopmuter
- world wide web: an information space where documents and other web resources are identified by uniform resource locators (urls), interlinked by hypertext links, and can be accessed via the internet
- url: uniform resource locator: web address: a reference to a web resource that specifies its location on a computer network and a mechanism for retrieving it
- the internet: the global system of interconnected computer networks that use the internet protocol suite (tcp/ip) to link devices world wide
  - a network of networks that consists of private, public, academic, business and government networks of local to global scope, linked by a broad array of electronic, wireless, and optical networking technologies
- remote administration: refers to any method of controlling a computer from a remote location
- file transfer: the transmission of a computer file through a communication channel from one computer system to antoher
- internet protocol: the principal communications protocol in the internet protocol suite for relaying datagrams across network boundaries
  - its routing function enables internetworking and essentially establishes the internet
- stateless protocol: a communications protocol in which no information is retained by either sender/receiver
  - the sender transmits a packet to the receiver and does not expect an acknowledgement of receipt
- transport layer: a conceptual division of methods in the layered architecture of protocols in the network stack in the internet protocol suite and the open systems interconnection
- network address: an identifier for a node/network interface of a telecommunications network
  - designed to be unique identifiers across the network, although some neworks allow for local, private addresses or locally administerd addresses that may not be globally unique
- router: a networking device that forwards data packets between computer networks
  - perform the traffic directing functions on the internet
  - a data packet is typically forwarded from one router to another router through the networks that constitute an internetwork until it reaches its destination node
- residential gateway: home gateway: allows the connection of a local area network (LAN) to a wide area network (WAN)
  - the wan can be a larger computer network like a municipal WAN or the internet
- local area network: a computer network that interconnects computers within a limited area, e.g. residence, school, etc
- wide area network: WAN: a computer network that extends over a large geographical distance, are often established with leased telecommunications circuits

# background

## The World Wide Web

- is just a small part of the internet
- is a platform for web developers to publish ideas to the world
- it is clients (browsers) communicating with servers
- its all about publishing and accessing documents/information
- history:
  - tim berners lee created the web in order for researchers to easily transfer documents between each other
  - he created a subset of SGML and called it HTML
  - he created HTTP, which is designed to transfer HTML
- architecture
  - HTTP > TCP > IP > ethernet
    - http:
    - TCP: impacts how we format our requests for best performance
      - allows us to have multiple streams of data between connections
      - each stream is distinguished by PORT numbers
      - 3 way handshake to make a new connection on http
        1. i ask you: i want to talk
        2. you ask me: you heard i want to talk
        3. i tell you: yes, that is correct
        4. for https, and additional TLS handshake must be executed
    - IP: determines how we talk to other machines on the net
    - ethernet

# client server model

- a distributed application structure that partitions tasks/workloads between the providers of a resource/service (servers) and service requesters (clients)
  - use by:
    - email
    - network printing
    - world wide web
- describes the relationship of cooperating programs in an application

## client and server communication

- service: an abstraction of computer resources
- the client must understand the response based on a well-known application protocol that describes the content and the formatting of the data for the requested service
- client sends a request and the server returns a response
  - the client and server must have a common language, and they must follow rules so that both know what to expect
    - communication protocols operate in the application layer
    - to formalize the data exchange even further, the server may implement an application programming interface

## servers: resource/service providers

- host: runs one/more server programs which share their resources with clients
  - a computer/other device connected to a copmuter network, oferring information resources/services/applications to users/other nodes on the network
  - is assigned a network address
- are classified by the services they provide

### web server: serves web pages

- computer system that processes requests via http, the basic network protocol used to distribute information on the world wide web.

### web cache server

- i.e. http cache
  - clients can also store content for reuse
    - e.g. when you press the back button, the locacl cached version of a page may be displayed instead of a new request being sent to the web server
- information technology for the temporary storage of web documents/pages, images, to reduce server lag
- stores copies of documents passing through it
  - subsequent requests may be satisfied from the cache if certain conditions are met
- web cache system: either an appliance/computer program
- forward position system: recipient/client side
  - forward cache is a cache outside the web server's network, e.g.
    - on the client computer
    - in an ISP
    - within a corporate network
  - network aware forward cache: caches heavily accessed items

### proxy server

- acts as an intermediary for requests from clients seeking resources from other servers
  - a client connects to the proxy server, requesting some service, and the proxy server evaluates the requests as a way to simplify and control its complexity
  - invented to add structure and encapsulation to distributed systems
- these are servers that sit between you and some other server
- useful for:
  1. adding additinoal compression
  2. downsampling images
  3. doing aggressive caching

#### web proxy server

- forwards http requests

-

### upstream server

- a server that provides service to another server
  - a server that is located higher in the hierarchy of servers
  - the highest server in the hierarchy is sometimes called the 'origin server'

### file server: serves computer files

- a computer attached to a network that provides a location for shared disk access, that can be accessed by workstations that are able to reach the computer that shares the access through a computer network
- its common that file servers do not perform computational tasks/run programs on behalf of clients
- designed to enable the storage and retrieval of data while the computation is carried out by the clients

### CDN

- content delivery network: system of distributed servers that deliver assets to a user based on geographic locations of the user, the origin of the assets, and a content delivery server
  - the closer the CDN server to the user geographically, the faster the content will be dleivered to the user.

### API

- application programming interface
- an abstraction layer for accessing a service

### inter-server communication

- an extension of the client-server model in which data are exchanged directly between servers
- aka server to server or inter-domain

#### Domain name system: DNS

- uses an inter-server protocol for zone transfers
- a hierarchical decentralized naming system for computers, services or other resources connected to the itnernet or a private network
- associates various information with domain names assigned to each o fhte participating entitites
  - e.g. translates more readiliy memorized domain names to the numerical IP addresses needed for locating and identifying computer services and devices with the underlying network protocols

#### dynamic host configuration protocol: DHCP

- a standardized network protocol used on internet protocol networks
  - the DHCP is controlled by a DHCP server that dynamically distributes network configuration parameters, e.g. IP addresses, for itnerfaces and services
  - enables computers to request ip addresses and networking parameters automatically, reducing the need for a network administrator or user to conifgure these settings manually
- router/residential gateway can be enabled to act as a DHCP server

-

## clients: resource/service requesters

- does not share any resources, but requests a server's content/function
  - initiate communication sessions with servers which await incoming requests
- user agent: software agent that is acting on behalf of a user, e.g. a web browser, email readerweb crawlers/bots, voice browsers, mobile apps, etc

# http

## high level

- http: hyper text transfer protocol: an application layer protocol for transmitting hypermedia documents, e.g. html
  - designed for communicatino between web browsers and web servers
  - follows the classic client-server model
  - is a stateless protocol
  - can be used on any reliable transport layer (not just tcp/ip)
  - is public, and anyone can eaves drop on your requests and responses
  - functions as a request-response protocol in the client-server computing model
  - permits intermediate network elements (e.g. caches) to improve/enable communications between clients and servers
- hyper text: structured text that uses logical links (hyperlinks) between nodes containing text

## http transaction layers

- client perspective
  1. HTTP: application layer: sits on the top
  2. TCP: transport control protocol: transport layer
  3. IP: internet protocol: network layer
  4. ethernet/IEEE 802.11: data link layer
  5. drivers / cards: physical layer
- switch perspective
  1. ethernet:
  2. drivers/cards:
- router perspective
  1. ethernet
  2. drivers/cards
- server perspective 1. messageL application layer 2. segments: transport layer 3. packats: network layer 4. frames: data link layer 5. drivers/cards:
  .

## HTTP Requests and Responses

- http data rides above the TCP protocol in the application layer
  - TCP protocol guarantees reliability of delivery and breaks down large data requests and responses into network-manageable chunks
    - is a connection orientated protocol that manages the connection between client and server
  - all HTTP data is expressed in human-readable ASCII text (as opposed to http2 data which is not human-readable)
- synchronous requests: block the execution of code which creates 'freezing' on the screen and an unresponsive user experience
  - inline javascript
- asynchronous requests: client receives a callback when the data has been received allowing the browser to work as normal while the request is being handled
- bottlenecks in request-response performance
  - large # of redirects
  - images/videos without optimizations e.g. compression and form factor aware content delivery
  - blocking/long running javascript
  - performance tax of using SSL
  - large # of third party services which are out of your control for optimization
- optimizations
  - resource consolidation
    - avoid redudant download of script files
    - sprite your images
    - use browser cache + local storage
    - embed (inline) resources in html that have low re use to limit the # of requests
      - images + binary resources can be inlined via data URIs that are base64 encoded
    - eliminate redirects
  - reduce payload
    - use compression
    - use minification
    - dynamically resize images
  - optimize client side processing
    - defer rendering of below the fold content
    - defer loading and execution of scripts
    - adapt to network connection
    - use html5 web workers for multi threading
  - TCP related optimizations for http
    - TCP fast open
    - proportional rate reduction for TCP
    - Tail Loss Probe
    - use SPDY
    - use http2

### http request - response metrics and document life cycle events

- time to first byte (TTFB) the time it took from teh request being issued to receiving the first byte of data from the primary URL
  - no redirects: DNS + TCP Connection + Send + Wait
  - with redirects: Sum of TTFB for each domain in the redirect chain
- Response: the elapsed time betwen request being issued and primary host server responding with the last byte of the primary url
  - for redirects: the sum of response times for each domain in the redirect chain
- server response: the elapsed time between the DNS resolution and the server responding with the last byte of the primary url
  - i.e. the servers response time sans DNS resolution time
  - for redirects: sum of server response time for each domain in the redirect chain minus DNS resolution time
- render start: the time it took the browser to start rendering the page
- document complete: even indicating the browser has finished rendering the page

  - chrome: browser onload event
  - IE: document ready stte changes to complete

-

### simple http transaction

- one where the client makes a single request for http content
- anatomy and flow
  - Domain Name Resolution
    1. DNS Lookup
    - client tries tries to resolve the domain name for the request
      - client sends DNS query to local ISP DNS server
      - DNS server responds with the IP address for hostname.com
  - Three Way TCP Handshake 2. TCP CONNECTION OPEN - client establishes TCP connection with the IP address of hostname.com - client sends SYN packet - web server sends SYN-ACK packet - client answers with ACK packet, concluding the three way TCP connection establishment
  - Client-Server Request Response 3. CLIENT REQUEST
    - client sends teh HTTP request to the web server 4. CLIENT WAIT
    - client waits for the server to respond to the request
    - SERVER RESPONSE
      - server processes the request, finds the resource, and sends the response to the client
    - CLIENT RECEIPT
      - client receives the first byte of the first packer from server
      - contains the HTTP response headers and content
      5. CLIENT LOAD
    - client loads the content of the response
    - server sends second TCP segment with the PSH flag set
    - client sends ACK
      - client sends ACK every two segments ir receives from host
    - server sends third TCP segment with HTTP_Continue 6. TCP CONNECTION CLOSE
    - client sends a FIN packet to close the TCP Connection

### Serial HTTP Connection

- when multiple requests are issued sequentially to a server and each request establishes a new connection
  - only occurs when:
    - a browser/server only supports HTTP 1.0 without Keep alive
    - a browser/server only supports HTTP 1.0+ and the first request is a blocking requests (e.g. inline javascript request)
- rarely occurs because all modern browsers support parallel connections to a host server
- Anatomy and flow (abbreviated)
  - request 1
    1. DNS LOOK UP
    2. TCP CONNECTION OPEN
    3. CLIENT REQUEST
    4. CLIENT WAIT
    5. SERVER RESPONSE
    6. CLIENT LOAD
  - request 2
    1. TCP CONNECTION OPEN
    2. CLIENT REQUEST
    3. CLIENT WAIT
    4. SERVER RESPONSE
    5. CLIENT LOAD

### Persistent HTTP Transactions

- allow the browser/http client to utilize the same connection for different object requests to the same hostname
- HTTP 1.1 protocol supports persistent connections natively
- HTTP 1.0 protocol requests the Keep-Alive http header
- anatomy and flow
  - Domain name resolution
    1. DNS LOOKUP
  - persistent TCP connection open
  - multiple serial requests 2. CLIENT REQUEST X 3. CLIENT WAIT X 4. CLIENT LOAD X

### Parallel HTTP transactions

- HTTP 1.0 requires Keep-Alive header and has different implementation
- HTTP 1.1 permits clients to open multiple TCP connections and perform HTTP requests in parallel

  - requirements
    - the first TCP connection has been established
    - the first request to the first connection is completed
    - now additional TCP connections can be established
    - all TCP connections can send their requests in parallel
  - anatomy and flow

    1. DNS lookup to hostname1
    2. TCP connection to hostname1
    3. client request to hostname 1
    4. client wait from hostname 1

    - server response from hostname 1 5. client load from hostname 1
    - now the cycle can repeat for sending requests to multiple hostnames via distinct TCP connections

    -

-

### http messages

```js
  // http request anatomy
    GET / HTTP/1.1
    Host: developer.mozilla.org
    Accept-Language: fr

    // GET = method
    // / = path
    // HTTP/1.1 = version of the protocol
    // Host... and reminaing lines = Headers

  // http response anatomy
    HTTP/1.1 200 OK
    Date: Sat, 09 Oct 2010 14:28:02 GMT
    Server: Apache
    Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
    ETag: "123-abc-123-abc"
    Accept-Ranges: bytes
    Content-Length: 223458
    Content-Type: text/html
    // HTTP/1.1 = version of the protocol
    // 200 = Status Code
    // OK = Status message
    // Date... and remaining lines = Headers
```

- how data is exchanged between a server and client
  - requests: sent by client to trigger an action on server
  - responses: answer from server
- http 1.1/0:
  - textual information encoded in ASCII
  - span multiple lines
- http 2:
  - divided into HTTP frames for optimization and performance improvements
- http message initiation
  - APIs / scripts
  - UI activity in browser
  - HTML forms in browser
  - config file in server
- http message structure
  - http 1.1/0
    - start line:
      - client: METHOD PATH HTTP VERSION
      - server: status code
    - HEADERS (1 per line)
      - client: headers describing request
      - server: headers describing body
    - BLANK LINE
      - indicates the end of medidata and start of body
    - BODY (optional)
      - client: e.g. form data
      - server: e.g. the requested resource
  - http 1.1/0 example
    - PUT /create_page HTTP 1.1
    - Host: blah.com:80
    - Connection: keep-alive
    - _more headers_
    - Body line X
  - http/2 stream (each line is a frame)
    - Type = HEADERS
    - Type = CONTINUATION
    - Type = DATA
      - multiple lines for data
- request body
  - requests fetching resources usually dont have a body
  - requests sending data usually require one
  - two broad categories
    - single resource bodies: consist of one single file defined by two headers
      - content type
      - content length
    - multiple resource bodies: consist of multipart body, each containing a different bit of information
      - typically associated with html forms

#### http message methods

- the client informs the server the action to take
- get
- put
- post
- head
- options

#### request and response HTTP header fields

- components of the header section of request and response messages in HTTP
  - define the operating parameters of an HTTP transaction
- request headers
  - general headers: apply to the whole http message
    - Via
  - request headers: modify the request by specifying it further/giving context/conditionally restricting it
    - user-agent
    - accept-type
    - accept-language
    - referer
    - if-none
  - entity headers: apply to the body of the request
    - content-length

#### http message body

-

### Requests

#### Request Methods

- GET: retriev stuff
- POST: create new stuff
  - the response should redirect to the newly created stuff
- PUT: update existing stuff
- DELETE: duh!
- HEAD: get the headers of a file, without the actual file
  - useful for:
    - checking if there is enough space to store the response
    - if your cached version is still up to date
    - only useful for very large files, as you will incur two round trips
- OPTIONS: get a list of methods that are accepted on the current URL
  - Post: you should respond to post requests with a redirect so that reloading the page doesnt cause an additional post
- HTTP Flow:

  1. open a TCP connection
  2. send an HTTP message

     ```js
     // GET / HTTP/1.1
     // Host: developer.mozilla.org
     // Accept-Language: fr
     ```

  3. read the response sent by the server

     ```js
     // HTTP/1.1 200 OK
     // Date: Sat, 09 Oct 2010 14:28:02 GMT
     // Server: Apache
     // Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
     // ETag: "51142bc1-7449-479b075b2891b"
     // Accept-Ranges: bytes
     // Content-Length: 29769
     // Content-Type: text/html
     //
     // <!DOCTYPE html... (here comes the 29769 bytes of the requested web page)
     ```

  4. close/reuse the connection for further requests

##### Request Headers

- Connection: Keep Alive
  - informs the server to keep the connection open after it returns the response
  - this allows you to send multiple requests to the same server, without having to go through the TCP 3 way handshake each time
- Cookie: all cookies previously sent in server responses and stored in browser

#### Responses

- response structure: only requires http version line and content-length header
  - HTTP/1.1 200 OK
    - http version, status code, status text
  - Headers
    - Content-Length:
    - Server:
    - Etag:
    - Content-Type:
    - Date:
    - Set-Cookie
      - server sends to browser
      - browser stores it and sends it back with the next request
      - useful for:
        - session management: logins, shopping carts,
        - personalization: user preferences, themes, other settings
        - tracking: recording and analyzing user behavior
      - Session Cookies:
        - deleted when the client shuts down
      - Permanent cookies
        - expire at a specific Date/Age
          - Set-Cookie: blah=blah, Max-Age=28days, Expires=Wed, 21 Oct 2016 7:27:00 GMT; (relative to the client)
      - Secure Cookies
        - requite Https
        - Set-Cookie: blah=blah, Secure, HttpOnly;
          - HttpOnly = prevent cross-site scripting attacks, cookie inaccessible to javascript ( cant access it in Document.cookie)
  - Binary data: the actual data

## REST: REpresentational State Transfer

- architectural strategies for implementing all the HTTP methods
- basic entitires are collections and entities inside those collections
  - GET <collection name>/<item name>

# HTTP2

- a major revision of the HTTP network protocol used by the world wide web
  - derived from the earlier experimental SPDY protocol developed by google
  - requires ALPN
- head of line requests: when one request is blocking others from completing
  - a browser will open at most 6 simultaneous connections to a server
  - you will have to wait for a round trip (req + res) to complete before another request can happen
- benefits
  - header compression
    - all streams share the browser compressor, so headers never have to be sent twice
  - multiplexing: combining multiple connections into a single connection via streams
    - streams are split up into frames
    - resolves head of line blocking
  - concatenating JS/CSS files is no longer necessary since head of line blocking is gone
    - its also worse to serve one big file, vs a lot of small files, for sites that use caching
      - you are forcing your users to download the concated files, instead of the single file that changed

# https

- is secured, no one can eaves drop on your requests or responses
  - it encrypts the requests and responses between server and client
  - authentication: this stops man in the middle attacks
- man in the middle attacks
  - someone inserts their server in between you and the server you want
  - even though its https, there intercept, and relay to your requested server, and still hijack your requests and responses
- HTTPS = http + TSL (formerlly ssl)

## TLS (formerlley ssl)

- TLS: transport layer security, can be use with any protocol, e.g. FTP has FTPS
  - cryptographic protocols that provide communications security over a computer network
  - encrypts communcation via a certificate issued by a certificate authority
    - metadata about the server
    - an encrypted fingerprint to decode communication
    - certificates validates a server, and the owner of the server
- see all certificates: chrome://settings/search#Certificates
- Encryption
  - symetric encryption (i.e. public key encryption): you encrypt some data with a key, pass the data to someone else, who has a symetrical key for unlocking the data
    - <http://hitachi-id.com/concepts/asymmetric_encryption.html>
  - browser encryption:
    - encryption key: is public (i.e. the public key), so anyone can send an encrypted message
    - decryption key: is private (i.e. the private key), so only the client can decrypt the message
- Hashing
  - the process of transforming data into a short representation of the original data
    - the smallest change in the original data will have enormous changes in the hash
      - if two documents yield the same hash, it is a super high probability they are the same document
  - hashing requirements:
    1. should be impossible to undo the hash transformation
    2. should be impossible to create two identical hashes from distinct documents
  - types of hashing:
    - the number says how big the hash is in bits
      - no matter how big the document is that you pass in, you will always get the # of bits indicated
    - SHA1:
    - SHA256:
    - SHA512:

### TLS handshake

1. server sends client the certificate

   - public key
   - domain the certificate is for
   - signature by the certificate authority

2. client confirms information

   - is domain correct?
   - is the authority signature valid?
     - all browsers have a collection of a certificate authorities including their public keys

3. client generates a random key for symmetric encryption to be used from here forward

   - the browser encrypts the random key with the servers public key
   - symmetric is faster than assymetric encryption
   - only the server can decrypt the random key with the private key and access the information

### TLS (ssl) errors

- certificate authority signature is invalid
- server is unable to communicate after switching to ssymetric encryption
- certificate expires (they have expiration dates)
- certificate is valid, but the server is invalid

### Certificates

- An invalid certificate is where the URL for the certificate does not match the URL in the browser's address bar
- an invalid signature, is when the decrypted hash does not match the one signed by the certifcate
- Certificate Authorities: sign (validate) certificates
- To speed up the encrypting and decrypting process, only the HASH is encrypted,
- Self signed certificates:
  - these certificates refer to themselves as their own certificate authority
  - browsers will complain

### Mixed Content

- when a TLS secure origin requests non secure content
- you can get pass this by only consuming securing content

### application layer protocol negotiation ALPN

- a transport layer security (TLS) extension for application layer protocol negotiation
  - allows the application layer to negotiate which protocol should be performed over a secure connection in a manner that avoids additional round trips and which is independent of the application layer protocols
  - required by HTTP2

# CACHING

- **what is it**
  - temporarily storing content/responses from previous requests, core part of content delivery strategy implemented with http protocol
  - components throughout the delivery path can cache items to speed up subsequent requests, subject to caching policies declared for the content
- **benefits**
  - decreased network costs: when content is cached closer to consumer, requests will not cause as much additional network activity beyond the cache
  - improved responsiveness: caching enables content to be retrieved faster
  - increased performance on the same hardware: for the server where the content originated, more performance can be squeezed by allowing aggressive caching.
  - availability of content during network interruptions: with certain caching policies, caching can be used to serve content to end users when it may be unavailable from origin servers
- **terminology**
  - origin server: original location of content, responsible for serving all content that cannot be retrieved from a cache along the request route and for setting the caching policy for all content
  - cache hit ratio: a cache's affectiveness measured in terms of its cache hit ratio or hit rate
  - cached requests / total requests
  - a high cache hit ratio is usually the desired outcome
  - freshness: whether an item within a cache is still considered a candidate to serve to a client
  - content in a cache will only be used to respond if it is within the freshness time frame specified by the caching policy
  - stale content: items in cache expire according to the cache freshness settings in the cache policy. expired content is stale
  - origin servers must be re-contacted to retrieve the new content or at least verify that the cached content is still accurate
  - validation: Stale items in the cache can be validated in order to refresh their expiration time. Validation involves checking in with the origin server to see if the cached content still represents the most recent version of item.
  - Invalidation: removing content from the cache before its specified expiration date. This is necessary if the item has been changed on the origin server and having an outdated item in cache would cause significant issues for the client.
- **types of caches**
  - application cache:
  - memory cache:
  - Intermediary caching proxies: Any server in between the client and your infrastructure can cache certain content as desired. These caches may be maintained by ISPs or other independent parties.
  - Reverse Cache: Your server infrastructure can implement its own cache for backend services. This way, content can be served from the point-of-contact instead of hitting backend servers on each request.
  - web/browser cache: Web browsers themselves maintain a small cache.
    - core design of the http protocol meant to minimize network traffic while improving the perceived responsiveness of the system as a whole
    - _how it works_
      1. caching the HTTP responses for requests according to specified rules
      2. subsequent requests for cached content are fullfilled from a cache closer tot he user instead of sending the requests all the way back tot he web server
- **what can be cached**:
  - cache friendly items: anything that is static/near-static
    - images, especially static images like icons, logos, etc
    - stylesheets
    - javascript files
    - downloadable content
    - media files
  - cache unfriendly items: anything that is dynamic, or is changed frequently, must be cached with care
    - html pages
    - rotating images, e.g. user profile pics
    - content requested within authentication cookies
  - cache hatred items: things you should never cache
    - assets related to sensitive data ( e.g. banking )
    - user specific content and frequently changed
- **cache headers**
  - caching policy: determined by content owner and specified via specific http headers
    - caching entity decides how much to cache, but never more than specified by caching policy
  - Http headers related to caching
    - Expires: sets a time in the future when the content will expire. replaced by Cache-Control: max-age, but this should still be used as fallback for old browsers.
      1. Any requests for the same content will have to go back to the origin server.
    - Cache-Control: replacement for the Expires header but is best to use both
      - enumerated values:
        - **for all cache types**
          1. no-cache: This instruction specifies that any cached content must be re-validated on each request before being served to a client. This, in effect, marks the content as stale immediately, but allows it to use revalidation techniques to avoid re-downloading the entire item again.
          2. no-store: This instruction indicates that the content cannot be cached in any way. This is appropriate to set if the response represents sensitive data.
          3. public: This marks the content as public, which means that it can be cached by the browser and any intermediate caches. For requests that utilized HTTP authentication, responses are marked private by default. This header overrides that setting.
          4. private: This marks the content as private. Private content may be stored by the user's browser, but must not be cached by any intermediate parties. This is often used for user-specific data.
          5. max-age: This setting configures the maximum age that the content may be cached before it must revalidate or re-download the content from the origin server. In essence, this replaces the Expires header for modern browsing and is the basis for determining a piece of content's freshness. This option takes its value in seconds with a maximum valid freshness time of one year (31536000 seconds).
          6. must-revalidate: This indicates that the freshness information indicated by max-age, s-maxage or the Expires header must be obeyed strictly. Stale content cannot be served under any circumstance. This prevents cached content from being used in case of network interruptions and similar scenarios.
          7. no-transform: This option tells caches that they are not allowed to modify the received content for performance reasons under any circumstances. This means, for instance, that the cache is not able to send compressed versions of content it did not receive from the origin server compressed and is not allowed.
        - **only for intermediary caches**
          1. s-maxage: This is very similar to the max-age setting, in that it indicates the amount of time that the content can be cached. The difference is that this option is applied only to intermediary caches. Combining this with the above allows for more flexible policy construction.
          2. proxy-revalidate: This operates the same as the above setting, but only applies to intermediary proxies. In this case, the user's browser can potentially be used to serve stale content in the event of a network interruption, but intermediate caches cannot be used for this purpose.
        - **gotchas**
          1. _no-cache_ and _no-store_ should not be used together
          - if they are, _no-store_ wins 2. For responses to unauthenticated requests, _public_ is implied 3. For responses to authenticated requests, _private_ is implied
    - Etag: used with cache validation. The origin will either tell the cache that the content is the same, or send the updated content (with the new Etag).
      1. The origin can provide a unique Etag for an item when it initially serves the content.
      2. When a cache needs to validate the content it has on-hand upon expiration, it can send back the Etag it has for the content.
    - Last-Modified: This header specifies the last time that the item was modified.
      1. This may be used as part of the validation strategy to ensure fresh content.
    - Content-Length: Certain software will refuse to cache content if it does not know in advanced the size of the content it will need to reserve space for.
    - Vary: A cache typically uses the requested host and the path to the resource as the key with which to store the cache item. this provides you with the ability to store different versions of the same content at the expense of diluting the entries in the cache.
      1. used to tell caches to pay attention to an additional header when deciding whether a request is for the same item.
      2. This is most commonly used to tell caches to key by the Accept-Encoding header as well, so that the cache will know to differentiate between compressed and uncompressed content.
    - Accept-Encoding: This is needed to correctly serve items to browsers that cannot handle compressed content and is necessary in order to provide basic usability.
    - User-Agent:
- caching policies:
  - purpose:
    1. aim to balance between implementing long-term caching and responding to the demands of a changing site.
    2. keep the cache hit-ration as high as possible while never serving stale content to users
  - issues:
    1. dynamically generated user content, sensitive data, should not be cached
  - questions:
    1. how should data that is not yet passed its expiration date, but has become stale due to new content availibity, be handled?
  - recommendations:
    - split your content into 3 buckets: The goal is to move content into the first categories when possible while maintaining an acceptable level of accuracy.
      1. Aggressively cached items
      2. Cached items with a short freshness time and the ability to re-validate
      3. Items that should not be cached at all
    - general recs
      1. Establish specific directories for images, css, and shared content: Placing content into dedicated directories will allow you to easily refer to them from any page on your site.
      2. Use the same URL to refer to the same items: Since caches key off of both the host and the path to the content requested, ensure that you refer to your content in the same way on all of your pages.
      3. Use CSS image sprites where possible: CSS image sprites for items like icons and navigation decrease the number of round trips needed to render your site and allow your site to cache that single sprite for a long time.
      4. Host scripts and external resources locally where possible: If you utilize javascript scripts and other external resources, consider hosting those resources on your own servers if the correct headers are not being provided upstream. Note that you will have to be aware of any updates made to the resource upstream so that you can update your local copy.
      5. Fingerprint cache items: For static content like CSS and Javascript files, it may be appropriate to fingerprint each item. This means adding a unique identifier to the filename (often a hash of the file) so that if the resource is modified, the new resource name can be requested, causing the requests to correctly bypass the cache. There are a variety of tools that can assist in creating fingerprints and modifying the references to them within HTML documents.
      6. Always provide validators: Validators allow stale content to be refreshed without having to download the entire resource again. Setting the Etag and the Last-Modified headers allow caches to validate their content and re-serve it if it has not been modified at the origin, further reducing load.
    - item type recs
      1. Allow all caches to store generic assets:
      2. Allow browsers to cache user-specific assets: For per-user content, it is often acceptable and useful to allow caching within the user's browser. While this content would not be appropriate to cache on any intermediary caching proxies, caching in the browser will allow for instant retrieval for users during subsequent visits.
      3. Make exceptions for essential time-sensitive content: If you have content that is time-sensitive, make an exception to the above rules so that the out-dated content is not served in critical situations. For instance, if your site has a shopping cart, it should reflect the items in the cart immediately. Depending on the nature of the content, the no-cache or no-store options can be set in the Cache-Control header to achieve this.
      4. Set long freshness times for supporting content: generally appropriate for items like images and CSS that are pulled in to render the HTML page requested by the user. Setting extended freshness times, combined with fingerprinting, allows caches to store these resources for long periods of time.
      5. Set short freshness times for parent content: In order to make the above scheme work, the containing item must have relatively short freshness times or may not be cached at all. This is typically the HTML page that calls in the other assisting content. The HTML itself will be downloaded frequently, allowing it to respond to changes rapidly. The supporting content can then be cached aggressively.

## caching

- choosing the optimal `Cache-Control` header policy
  1. response not resusable ? use `no-store`
  2. browser needs to revalidate the resource each time ? use `no-cache`
  3. cacheable by intermediate caches?
  - yes: use `public`
  - no: use `private` 4. maximum cache life time ? set `max-age=#` to # of seconds 5. add `Etag` header
- add a fingerprint to files in order to extend cache times and invalidate cache responses
  1. e.g. turn blah.css to blah.timestamp.css
  2. else embed a blah.css?v=timestamp inside of content

### headers

1. `Etag`: validation token to determine if a file has changed

   - if a browser has an asset that is expired, it can make a request to the server for the assets ETag

     1. if the servers etag === browser etag, it will continue to use the browser version from cache
     2. if they are different, it will send an additional request for the updated resource

   - the client automatically provides the ETag token in the "If-None-Match" HTTP request header.
     1. The server checks the token against the current resource. If the token hasn't changed, the server returns a "304 Not Modified" response
     - which tells the browser that the response it has in cache hasn't changed
     - updated `Cache-Control` header to be applied to the browser's version of the resource, e.g. to be renewed for another 120 seconds.

2. `Cache-Control`: control who can cache the response, under which conditions, and for how long

   - you can set multiple directives in `Cache-Control`

     1. `Cache-Control: private, max-age=600`

   - `Cache-Control: max-age=120`: cache for 120 seconds
   - `Cache-control: no-cache`: the returned response cant be used to satisfy a subsequent request to the same URL without first checking with the server to see if the response has changed (i.e. via `Etag` header)
   - `Cache-Control: no-store`: disallows the browser and all intermediate caches from storing any version of the returned response, e.g. for private or personal ifnormation like banking stuff
   - `Cache-Control: public`: this can be cached
     1. even if it has http authentication data associated with it
     2. even if the http response status code isnt normally cacheable
   - `Cache-Control: private`: the browser can cache it, but not intermediate caches
     1. this is usually for resources that are meant for a single user
   - `Cache-Control: max-age=#`: sets the max age for this resource to # in seconds

3. `Expires`:
