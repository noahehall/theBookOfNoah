# Javascript

- updated: 2023
- [web security in security dir](https://github.com/noahehall/theBookOfNoah/tree/master/0current/appdev/security)

## links

### interwebs

- [web standards](https://developer.mozilla.org/en-US/docs/Glossary/Web_standards)
- [eloquent javascript 3rd 2018](https://eloquentjavascript.net/)
- [web font performance](https://www.igvita.com/2014/01/31/optimizing-web-font-rendering-performance/)
- [es6 in depth articles](https://hacks.mozilla.org/2015/06/es6-in-depth-collections/)
- [web components in polymer](https://www.polymer-project.org/1.0/blog/es6)
- [real user monitoring: RUM](https://en.wikipedia.org/wiki/Real_user_monitoring)
- [latency vs bandwidth](https://www.igvita.com/2012/07/19/latency-the-new-web-performance-bottleneck/)
- [es6](https://ponyfoo.com/articles/es6)
- [Mixins](http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/)

### jakearchibald

- [the goat](https://jakearchibald.com/)
- [offline cookbook](https://jakearchibald.com/2014/offline-cookbook/)
- [progressive enhancement](https://jakearchibald.com/2013/progressive-enhancement-is-faster/)
- [remote debugging](https://jakearchibald.github.io/isserviceworkerready/index.html)
- [service workers](https://jakearchibald.github.io/isserviceworkerready/index.html)
- [streams](https://jakearchibald.com/2016/streams-ftw/#streams-the-fetch-api)

### google web dev

- [chrome timeline tool](https://developer.chrome.com/docs/devtools/)
- [Google Developer](https://developers.google.com/)
- [google webdev](https://web.dev/)
- [learn web dev](https://web.dev/learn/)
- [push notifications](https://developers.google.com/web/updates/2015/03/push-notifications-on-the-open-web)
- [PWA: progressive web apps](https://web.dev/progressive-web-apps/)
- [SEO](https://developers.google.com/webmasters/googleforwebmasters/)
- [serverice worker recipes](https://serviceworke.rs/)
- [web app manifest](https://web.dev/add-manifest/)
- [web dev explore](https://web.dev/explore/)
- [web dev patterns](https://web.dev/patterns/)

### js specification

- [tc39: js spec](https://tc39.es/)
  - [latest ecmascript standard](https://262.ecma-international.org/)
  - [process](https://tc39.es/process-document/)
  - [javascript versions](https://www.w3schools.com/Js/js_versions.asp)
  - [ecmascript spec](https://tc39.es/ecma262/)
  - [current proposals - all stages](https://github.com/tc39/proposals)
- [mdn: reference](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference)
  - [prototypical inheritance](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)
  - [destructuring](https://hacks.mozilla.org/2015/05/es6-in-depth-destructuring/)
  - [classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)
  - [for in](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in)
  - [for of](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of)
  - [RegExp](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)
  - [promises](- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)
  - [array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/)
  - [object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

### browser / server / apis

- [how browsers work](http://taligarsiel.com/Projects/howbrowserswork1.htm)
- [mdn browser API index](https://developer.mozilla.org/en-US/docs/Web/API)
  - [service workers](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers)
  - [Document](https://developer.mozilla.org/en-US/docs/Web/API/Document)
  - [events](https://developer.mozilla.org/en-US/docs/Web/Events)
  - [add event listener](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener)
  - [remove event listener](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener)
  - [touch events](https://developer.mozilla.org/en-US/docs/Web/API/Touch_events)
  - [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)
  - [request](https://developer.mozilla.org/en-US/docs/Web/API/Request)
  - [response](https://developer.mozilla.org/en-US/docs/Web/API/Response)
  - [headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers)
  - [localStorage](https://developer.mozilla.org/en-US/docs/Web/API/Storage/LocalStorage)
  - [indexedDb](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API)
  - [cross origin resource sharing](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS)
  - [cache control](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control)
  - [web workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)
  - [cache](https://developer.mozilla.org/en-US/docs/Web/API/cache)

### tools

- [regex tester](https://regex101.com/)
- [yslow](http://yslow.org/)
- [server configs](https://github.com/h5bp/server-configs)
- [lighthouse](https://developers.google.com/web/tools/lighthouse/)
- [google mobile friendly test](https://search.google.com/search-console/mobile-friendly)
- [mozilla SSL configuration](https://mozilla.github.io/server-side-tls/ssl-config-generator/)
- [manage all service workers](chrome://inspect/#service-workers)
- [page speed insights](https://developers.google.com/speed/pagespeed/insights/)
- [apache/nginx pagespeed optimize tool](https://developers.google.com/speed/pagespeed/module/)
- [css triggers](https://csstriggers.com/)
- [JIT in action](http://mrale.ph/irhydra/2/)
- [FastDOM](https://github.com/wilsonpage/fastdom)
- [android emulator](https://developer.android.com/studio/run/emulator.html#netspeed)
- [webpage speed test](https://developers.google.com/web/fundamentals/performance/poor-connectivity/)
- [free web debugging proxy](http://www.telerik.com/fiddler)
- [augmented traffic control](http://facebook.github.io/augmented-traffic-control/)
- [javascript AST visualizer](http://resources.jointjs.com/demos/javascript-ast)
- [jank free](http://jankfree.org/)

## basics

- js is single threaded: two things cannot run at the same time
  - Javascript is in the same queue as painting, updating styles, and handling user actions (e.g. highliting text/interacting with form controls)
  - thus concurrency is key to efficient js applications

### tc39 and web standards

- versions
  - es1: 1997
  - es2: 1998
  - es3: 1999
  - es4: never released
  - es5: 2009
  - es6: 2015
  - es7: 2016
    - etc
- process
  - stage 0: anything goes
  - stage 1: tc39 expects to devote time to examine the problem space, solutions & cross-cutting concerns
  - stage 2: tc39 expects the feature to be developed and eventually included in the standard
  - stage 3: tc39 expects the solution is complete, but needs feedback from the field
  - stage 4: feature will be included in the next ecmascript version
- web standards: rules established by international standards bodies and defining how the web works
  - IETF: internet engineering taskforce: govern setup and use of URIs, HTTP, and MIME
  - W3C: specifications for markup language (HTML), style definitions (CSS), DOM, and accessibility
  - IANA: internet assigned numbers authority: naame and number registries
  - Ecma Intl: scripting standards, prominently for javascript
  - ISO: international organization for standardization; standards governing a diverse array of aspects, e.g. character encodings, website management and UI design

### terms

- web sockets: a persistent connection to a server
- sourcemaps: tell the browser to convert line and column offsets 'for' exceptions thrown in the bundle file back into the offsets and filenames of the original sources.
- transpilers vs compilers: distinction is more fluid than binary and best throught of a spectrum from annotations > transpilers > compilers
  - annotations: e.g. jsdocs / flowtype
    - no transpilation / compilation required; simply remove the annotations
    - usually the best performance however feature limited based on context
  - transpilation: converting X to another version of X:
    - ESx > Babel > ESx
    - typescript > js
  - compilation: converting X to Y or a signficantly different version of X
    - nimlang > C > to js
    - coffeescript > to js

### Best Practices

- generally a good practice to have some throttling when testing sites. It'll help you see your sites performance from your users perspectives.
- online first: we try the network first, if it doesnt, we show some fallback content (or 404 page)
- offline first:
  - full content: deliver page header + content from cache, then update via network request
    - update cache on SW install
    - strategy for unobtrusive app updates
    - get the user onto latest version
    - continually update cache of posts
    - selectively cache everything you want available offline (e.g. images, posts, etc.)
  - header first: deliver page header from cache, attempt to retrieve content via network request, then fall back to cached content on device
- cache photos/media instead of storing them in db.
  - db: read data > convert to blob > store it. loses streaming capabilities
  - cache: request data > streams back > and can display it as it arrives (i.e. piece by piece)
- browser requests
  - request > http cache (found?) return page
  - else > go to internet > retrieve html>
  - other stuff needed ? > request css & javascript
- Search Fields
  - auto-completing queries, correct misspellings, suggest related queries
  - place filters above search results and always display # of results
- Ecommerce
  - allow users to purchase as guests
- mobile sites
  - Make calls to action front end center
  - Make secondary tasks available through menus/below the fold
  - make common tasks easily available
  - keep menus short and sweet
  - limit scrolling unless supported by the design / content
  - Site search bar should be above the fold, and never in a menu
  - show as much content as possible without requiring registration
- SEO
  - Interstitials may cause a negative impact on search rankings

## syntax

### scope

- determines the life, death and visibility of a variable
- block scope: lives within {}
- function scope: lives within function definitions/expressions/closures
- scope chain:
  - if the variable is not available in the current scope:
  - look for it in the parent function, if its not available there
  - go up one level, and continue all the way to the window (global) scope

### operators

- difference with `==`: The == operator applies various coercions to both sides (if they are not the same Type) before testing for equality (resulting in such behavior as "" == false being true), but Object.is doesn't coerce either value.
- difference with `===`: The === operator (and the == operator as well) treats the number values -0 and +0 as equal and treats Number.NaN as not equal to NaN.
- Spread Operator: expands an array/object into elements, i.e. flatten arrays and objects in function calls, array literals, destructuring assignment

### statements

- `break` Exits a 'switch' or a loop
- `continue` Breaks one iteration (in the loop) if a specified condition occurs, and continues with the next iteration in the loop
- `debugger` Stops the execution of JavaScript, and calls (if available) the debugging function
- `do ... while` Executes a block of statements and repeats the block while a condition is true
- `for` Marks a block of statements to be executed as long as a condition is true
- `for ... in` Marks a block of statements to be executed for each element of an object (or array)
- `function` Declares a function
- `if ... else ... else if` Marks a block of statements to be executed depending on a condition
- `return` Stops the execution of a function and returns a value from that function
- `switch` Marks a block of statements to be executed depending on different cases
- `throw` Throws (generates) an error
  - `throw "This is my error message"`
- `try ... catch ... finally` Marks the block of statements to be executed when an error occurs in a try block, and implements error handling
- `var` Declares a variable
- `while` Marks a block of stat
- `object instanceof constructor `//tests whether an object has in its prototype chain the prototype property of a constructor.
  `constructors === String, Number, Object, Date etc.`
- `debugger` pauses app run time at this point in the app.
  - you can open up console and type in any of the variables in the app, and it will print to the console
  - you can type in a function name and review it
  - you can click through the sources panel and view different things

### data conversion

- `String(x)` returns a string from a number variable x
- `toExponential()` Returns a string, with a number rounded and written using exponential notation.
- `toFixed()` Returns a string, with a number rounded and written with a specified number of decimals.
- `toPrecision()` Returns a string, with a number written with a specified length
- `Number("1.14") ` returns 1.14
- `parseFloat()` Parses a string and returns a floating point number
- `parseInt()` Parses a string and returns an integer

### variables

- let: block scoped vars
- var: global variable
- const: are block-scoped, much like variables defined using the let statement. The value of a constant cannot change through re-assignment, and it can't be redeclared.

#### destructuring

- Destructuring: pull values out of arrays/objects and assign them to variables

### Number

### Date

### String

### arrays

### objects

- obj.prototype.**proto**: The **proto** property of Object.prototype is an accessor property (a getter function and a setter function) that exposes the internal [[Prototype]] (either an object or null) of the object through which it is accessed.
- Object.setPrototypeOf(obj, prototype); sets the prototype (i.e., the internal [[Prototype]] property) of a specified object to another object or null.

### Maps

- answer yes to any of the below, and you can justify using a map
  - Are keys usually unknown until run time? Do you need to look them up dynamically?
  - Do all values have the same type? Can they be used interchangeably?
  - Do you need keys that aren't strings?
  - Are key-value pairs frequently added or removed?
  - Do you have an arbitrary (easily changing) number of key-value pairs?
  - Is the collection iterated?

#### Map

- new Map([iterable]): The Map object holds key-value pairs. Any value (both objects and primitive values) may be used as either a key or a value.
- properties
  - Map.prototype.size

#### WeakMap

- new WeakMap([iterable]): The WeakMap object is a collection of key/value pairs in which the keys are weakly referenced. The keys must be objects and the values can be arbitrary values.

### sets

#### Set

- new Set([iterable]): The Set object lets you store unique values of any type, whether primitive values or object references.

#### WeakSet

- new WeakSet([iterable]); If an iterable object is passed, all of its elements will be added to the new WeakSet. null is treated as undefined.

### functions

- anonymous enclosures
  - wrap the anonymous function in paranthesis
  - then call the function immediately by ending wtih () and send in parameters
  - any variables declared inside this function are local to this function
- function closures: defining a function within a function
- function parameters are variables that are local to the function
  - functions can return anything, even other functions
  - arguments = an array-like OBJECT containing all of the parameters passed to the function. it is NOT AN Array
- Rest Parameters: used in function arguments to capture a list of variables from arrays
- Default Arguments are assigned in the function signature

#### arrow functions

- do not create a new scope

### Control Flow

#### loops

- The break statement breaks the loop and continues executing the code after the loop (if any):
- The continue statement breaks one iteration (in the loop), if a specified condition occurs, and continues with the next iteration in the loop.

##### while

##### do while

##### for

##### for of

- The for...of syntax is specific to collections, rather than all objects. It will iterate in this manner over the elements of any collection that has a [Symbol.iterator] property.

##### for in

- The for...in statement iterates over the enumerable properties of an object, in original insertion order. For each distinct property, statements can be executed.

##### iterators

#### try catch

#### if

#### switch

#### generators

- Generators: a function that can be exited, and entered multiple times
- yield: exit the function and send a value to the caller, and optionally receive a value back
- function.next(): retrieve and send data, executes up to and including the next yield statement
  - for each yield statement you need to call blah.next()
  - returns `{value: 'dataInAndOut', done: true|false}`
    - value: data sent out from yield, or data sent in through next(someData);
    - done:
    - false if function is not done, and can be entered again
    - true: if function is done, and should not be re-entered
  - you can access the value directly: `bloop.next().value;``
- use cases
  - asynchornous events
  - timers (e.g. setInterval)
- Generators should not be re-used, even if the for...of loop is terminated early, for example via the break keyword. Upon exiting a loop, the generator is closed and trying to iterate over it again does not yield any further results.

### classes

#### prototypes

- prototype: each object has an internal link to another object, its prototype, that provides additional behavior and properties
  - classes are just syntactic sugar for prototypes
- prototype chain: the sequence of linked objects from one object's prototype to another, all the way up until you reach the Null object (which does not have a prototype)
- helps you create formalized objects (i.e. classes)
  - its simply a function that creates an object
  - new = the constructor operator, creates a new instance of an object
  - prototype object allows you to extend functions functionality after its created

#### class

- An important difference between function declarations and class declarations is that function declarations are hoisted and class declarations are not.
- The super keyword is used to call functions on an object's parent.
- Abstract subclasses or mix-ins are templates for classes. An ECMAScript class can only have a single superclass, so multiple inheritance from tooling classes, for example, is not possible. The functionality must be provided by the superclass.
- classes can be used as an expression as well as a statement
  - as an expression it returns a new class each time its evaluated (sort of like a factory)
- the extends clause accepts arbitrary expressions that return classes or constructors

#### Mixins

- mixin: is really a subclass factory, parameterized by the superclass, which produces mixin applications
- benefits of approach below: 0. the only difference between a mixin and a normal subclass is that a normal class has a fixed superclass, while a mixin definition doesnt (the mixin application does)
  - the definition of a class that may be applieed to different super classes.
  - mixin application: the application of a mixin definition to a specific superclass, producing a new subclass
- implementation features based on es6 classes
  - mixins are added to the prototype chain
  - mixins are applied without modifying existing objects
  - mixins do no magic, and dont define new semantics on top of the core language
  - superfoo property access works within mixins and subclasses
  - super() calls work in constructors
  - mixins are able to extend other mixins
  - instanceof works
  - mixins donot require library support and can be writtin in a universal style
  - subclasses correctly override mixin methods which override superclass methods.

### metaprogramming

- metaprogrammaning: all about the underlying mechanics of the language, rather than “high level” data modeling or business logic. If programming can be described as “making programs”, meta-programming could be described as “making programs making programs”
  - Code Generation, aka eval & friends -
  - Reflection - finding out about and adjusting the structure and semantics of your application
    - Functions:
      - Function#name
      - Function#length
      - Function#bind
      - Function#call
      - Function#apply.
    - Object.getOwnProperties (As an aside,
  - Introspection: Reflection tools that don’t alter code, but instead gather information about it are often called

#### symbols

- reflection within implementation - you sprinkle them on your existing classes and objects to change the behaviour.
- use cases:
  - not iterable over
  - not fetched using the already existing Reflection tools
  - guaranteed not to conflict with other properties in the object!
  - If you create a symbol (var mysym = Symbol()) it creates a completely new value inside the JavaScript engine.
    - If you don’t have the reference for the Symbol, you just can’t use it.
    - This also means two symbols will never equal the same value, even if they have the same description.
  - Symbol.for(). This method creates a Symbol in a “global Symbol registry”. Small aside: this registry is also cross-realm, meaning a Symbol from an iframe or service worker will be the same as one generated from your existing frame:

#### Reflect

- all about Reflection through introspection - used to discover very low level information about your code.

#### Proxy

- proxies: Proxies enable creation of objects with the full range of behaviors available to host objects. Can be used 'for' interception, object virtualization, logging/profiling, etc.
- Reflection through intercession - wrapping objects and intercepting their behaviours through traps.
- proxy types
  - no-op forwarding proxy
  - validation proxy

### regexp

### concurrency

- asynchronous: statements occur in multiple timelines, in an unknown order irregardless of how they are defined in code
  e.g. network requests, events, threads, timeouts, etc.
- synchronous: statements happen in order as defined, in a single timeline
- callbacks: pass one function (cb) to another function, and the cb is invoked when certain conditions are met
  - problems:
    - how do you handle errors ? do all type of errors get handled the same way ?
    - Pyramid of doom / callback hell:

#### promises

- try catch wrapper around code that will finish at an unpredictable time
  - can only succeed/fail once
  - cannot switch from success to failure/vice versa
  - if a promise has succeeded/failed, and you later add a success/failure callback, the correct callback will be invoked, even though the event took place earlier
  - any object with a then method can be used as and integrated with native promises
- Promise States
  - fulfilled (resolved): action related to the promise has succeeded
  - rejected (failure): action related to the promise has failed
  - pending: not yet fulfilled / rejected
  - settled: promise has either fulfilled / rejected.
  - a promise can only be settled once, whereas events can fire multiple times
  - promises are potentially blocking since they are created and settled on the main thread
- Promise stages:
  - wrapping: (value promise creation)
  - create a promise that wrapps an async action
  - thening (value -> action):
  - any object that returns a .then is thenable
  - any thenable can become part of a chain of thens/asynchronous work
  - catching (value -> recovery):
  - javascript calls the NEXT CATCH in the chain when an error occurs or a promise is rejected
- FYI
  - each Then is also asynchronous, so you can return a promise from a then, and the next then will only execute when the new promise is settled
  - the `.catch()` chain is just sugar for `then(successFunction, errorFunction)`
  - promise rejections skip forward to the next then() with a rejection callback or catch chain
  - rejections happen when a promise is explicitly rejected, or implicetly if an error is thrown in the constructor callback
  - thus, its best to do all your promise-related work inside the promise constructor callback, so errors are automatically caught and become rejections
  - you can combine generators and promises to write async code that looks like and easy to follow like sync code

#### async await

- basics
  - allow you to write promise-based code as if it were syncrhonous, but without blocking the main thread
  - Note that `await` may only be used in functions prepended with the `async` keyword
  - suspends execution in your context until the promise settles
  - `async` Function always returns a Promise
  - anything prepended with `await` is passed through Promise.resolve() so you can safely await non-native promises
- use cases
  - reduce complex promise logic
  - convert object/class methods to promises
  - Class constructors and getters/settings cannot be async.
  - easily run multiple async logic in serial/parallel
  - easily make requests in parallel but take action in order they were called
  - use them on every promise-returning function! Not only do they make your code tider, but it makes sure that function will always return a promise.

#### timers

### math

### module loaders

## Web Fundamentals

### CORS

- cross origin resource sharing
- A resource makes a cross-origin HTTP request when it requests a resource from a different domain, or port than the one which the first resource itself serves.
- the CORS mechanism gves web servers cross-domain access controls, which enable secure cross-domain transfers
  - the [CORS protocol](https://fetch.spec.whatwg.org/#http-cors-protocol) can enable cross-site HTTP requests for:
    - invocations of XMLHttpRequest/Fetch api
    - web fonts
    - images/video frames drawn to canvas using drawImage
    - stylesheets
    - scripts
  - add HTTP headers that allow web servers to describe the set of origins that are permitted to read
  - for HTTP methods with server side-effects (e.g. `POST`), the spec mandates that browsers _preflight_ the request to retrieve supported methods with an `HTTP OPTIONS` request method, and then upon _approval_ from the server, sending the actual request
  - servers can notify clients whether crednetials (e.g. cookies) should be sent with requests
- TERMINOLOGY
  - Simple requests: requests types that don't trigger a `CORS preflight`, i.e. GET, HEAD, POST
- server perspective
  - set _response.header_ `Access-Control-Allow-Origin:` to the domains that can access the server's resources
  - allow all: `Access-Control-Allow-Origin: *`
  - allow specific: `Access-Control-Allow-Origin: http://foo.example`
    - you can programmatically update this permit multiple domains access without using the `*` flag

### Progressive Web apps

#### Offline Web Apps

#### Service Workers

- `window.navigator.serviceWorker`
- service worker: a script your browser runs in the background and listens for and reacts to arbitrary events
  - each page the service worker controls, it hijacks all events and allows you to operate on them.
  - are limited to HTTPS, since intercepting network requests can be super dangerous in the wrong hands
  - cant access the DOM directly, but communicates with the pages it controls by responding to messages via the [postMessage](https://www.html5rocks.com/en/tutorials/workers/basics/) interface
  - is a programmable network proxy, allowing you to control how network requests from your page are handled
  - is terminated when not in use, and restarted when its nexted needed, so never rely on global state within a SW onfetch and onmessage handlers
  - has full access to the indexedDB api
  - make extensive use of promises
- use cases
  - adding offline support
  - control the cache
  - sending push notifications
  - You could send push notifications from the browser to your users about new posts, even if the client has closed your page, since service workers are in constant communication with your server in background.
  - doing background sync with service workers
  - Capability reporting
  - Client-side Load Balancer
  - Differential update of text files
  - Support a previous unsupported image format in your browser!
  - Save forms information even if theres no internet at the moment: Your application could have a huge form to send information for and, in case the user lost connection, the information could be saved in a Service Worker, even when the user is offline, and be sent to your server when the connection is back.
  - Faster page loads: You could cache scripts, images, stylesheets, static pages, etc on a Service Worker on a first page-load and run a faster page loading on subsequent requests. The approach is almost the same if you relate it with browser caching but differs with when talking about requests: browser caching requests are always made and stops only if you already have the information needed and with Service Workers caching, no requests are made to the server.
  - for some changes (e.g. minor, or security fixes) you may want to force changes to users
  - [push notifications](https://developers.google.com/web/updates/2015/03/push-notifications-on-the-open-web)
  - [background sync](https://developers.google.com/web/updates/2015/12/background-sync)
- life CYCLE
  - registration step: register a SW in your page's javascript: the browser will then install the SWin the background
  - SW Install step: you specify which static assets to cache. if all assets are successfully downloaded and cached, the SW becomes activated
  - create/open a cache
  - cache static assets
  - SW Activated step: handle management of old caches
  - for all pages within the SW scope, the SW will act as a Proxy or be terminated (to save memory),
  - clear current cache / delete old caches if upgrading to a new version
  - have the activated service worker take control immediately
    - this is the 'idle' phase
- process:
  - service workers are instantiated via javascript in the window, and can only take control of pages that are LOADED after they are instantiated.
  - page 1 loads > instantiates sw registration file > makes requests (none are intercepted)
  - user refreshes (causes new load) > sw still in browser > requests are intercepted
  - service worker intercepts all requests and triggers a 'fetch' event for each
  - instantiating a new SW can only occur if all pages controlled by the current SW are gone. this ensures only one version of your site exists at any given time
  - the new SW is in 'waiting' mode until the current SW is gone
  - only occurs if the page closes, or the user navigates to a page not controlled by the current SW
  - users are notified that a new SW is ready by changing the browser hamburger button in the top right (at least on chrome)
  - when the browser refetches a service worker, it goes through the browser cache for all requests
  - it is good to set your SW CACHE TIME TO ZERO!!!! this way they are updated as soon as possible
    -updates to will bypass the browser cache if the SW it has is > than the cache time
- service worker hijaking workflow:
  - client loads
  - service workers interact with caches
  - service workers interact with http caches
  - service workers interact with network/internet
- network flow: browser requests > service worker > http cache > internet
- gotchas
  - browsers only update service workers on page reload, or if there is a change to the SW (e.g. change cache name)
    - the new SW will have its only install event so you can use this time to get an updated cache
- DEV TOOLS:
  - click the down arrow next to 'top' and select your SW file
  - now you can interact with your SW
    self.registration
  - you can debug SW same as anything else:
    sources > click SW file > set breakpoints, etc.
  - click the application/resources tab and select the SW option
- Basic steps:
  - registration
    - in a script on the page, register a service worker
    - the service worker is registered on an origin, and controls a subset of paths (or root, for all paths)
      navigator.serviceWorker.register....
  - do stuff!
    - intercept network requests/events and do something with them (e.g. store the response in cache)
      self.addEventListener....
      caches.open...
    - events: install, fetch,
      event.someMethod()
    - caches.open(...)
      cache.someMethod()
- methods
  - postMessage(): send messages to/from SW
  - skipWaiting()
    - forces the waiting service worker to become the active service worker.
    - call this when a user hits the refresh button
- events
  - INSTALL: when a browser sets up a SW for the first time, the install event is fired.
  - ACTIVATE: when a new SW is finished installing and ready to control pages, use this event to delete old caches
  - FETCH: every browser request triggers a fetch, useful for hijacking/intercepting
  - MESSAGE: receive/post messages from/to the client (i.e. a page/document)

### Web Performance

- page performance
- browser rendering optimization

### Client-Server Communications

#### HTTP: hypertext transfer protocol:

- hypertext = text with links
- transfer protocol: rules for moving things across the web
- clients: asks (requests) servers for resources
- servers: store information and sends (response)
- REST: Representational State transfer
  - state transition: going from one state (page) to another (page)
  - separate client from server
  - should not hold state between requests (all information is sent with each response)
  - use HTTP and HTTP methods
- HTTP Requests:
  - Request: tells the server what kind of request (method) is being sent
    // POST /codecademy/learn-http HTTP/1.1
  - Header: sends the server additional information, e.g. which client is making the request
    // Host: www.codecademy.com
    // Content-Type: text/html; charset=UTF-8
  - body: contains the data being sent
    GET: body = empty
    POST/UPDATE/DELETE: body should not be empty
    // Name=Eric&Age=26
- [HTTP Responses](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes)
  - Status Codes: three digits, the starting number defines the type
  ```
    1xx: information
    2xx: success
    3xx: redirection
    4xx: client error
    5xx: server error
    6xx: unofficial Codes
  ```
- [HTTP Request Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods)
  - GET: retrieve data
  - HEAD: asks for a response identical to a GET request but without the response body
  - POST: submit data
  - PUT: replaces data
  - DELETE: delete data
  - CONNECT: establishes a tunnel to the server
  - OPTIONS: describe the communication options
  - TRACE: performs a message loop-back test along the path to the server
  - PATCH: used to apply partial modifications

### browser events

- Event Registration: telling javascript you want to react to specific events when they happen via an event handler
  - using tag attributes
    `onclick="alert('show this message on click')"`
  - using dot notation
    `document.getElementById('blah').onclick=function(){alert('show this message on click');}`
  - using addEventListener()
  - it allows us to check for multiple events in a single call (aka event propagation)
  - and events can be triggered via non DOM objects (i.e. write your own events)
  - it is not supported by IE 8 or lower (you have to use an if statement to check for the other one)
- event.preventDefault(): stops the browser from continuing to process the event, it does not stop propagation
- event.stopPropoagation(): prevents further propagation of the event in the capturing and bubbling phases
- Event objects
  - capturing an event returns an event object
  - event objects will be different in each browser, console log it to see:
  - event info
    - type = e.g. click
    - timestamp = the time it happened
    - defaultPrevented = if you are preventing the default behavior
  - event targeting info
    - currentTarget = the element the event was assigned to
    - target = the element the event originated from
    - srcElement = the actuall element that fired the event
    - fromElement = mouse over and mouse out events
    - toElement = mouse over and mouse event events
  - coordinate info:
    - screen X,Y: position relative to the users screen
    - layer x, y: position relative to the another positioned event
    - client x,y: position relative to the window
    - page x,y: position relative to the document
    - offset x,y: position relative to the element that fired the event
  - key/mouse info
    - charCode/Keycode: which character was pressed
    - altKey:
    - shiftKey:
    - ctrlKey:
    - button:
  - Event propagation
    - a parent event can capture events from is child elements
    - only available when using addEventListener
  - capturing phase: moves down from parent to child element
  - bubbling phase: moves up from child to parent element
  - stopping propoagation
    `e.stopPropoagation()``
    - stop the event from moving up/down the DOM
    - use this after you're done with the event
  - Event Default behavior
  - clicking on links, submitting forms, etc.
    `e.preventDefault() //stops the default behavior`
- touch events
  - low level APIs to support application specific touch interactions like two finger gestures
  - are similar to mouse events except they support simultaneous touches and at different locations on the touch surface
  - the TouchEvent interface encapsulates all of the touch points that are currently active
  - events: touchstart, touchmove, touchend, touchcancel, touchend

#### event tips

- setup event handlers on the body.onload attribute and attach event handlers to all elements that require it
- calling evt.preventDefault() on touchstart / first touchmove will cancel mouse events
  - instead only call preventDefault() on touchmove, or fire touch events as mouse events
- Use the event object to tailor actions to events.
  - Each touch event includes three lists of touches.
    - touches: a list of all fingers currently on the screen.
    - targetTouches: a list of fingers on the current DOM element.
    - changedTouches: a list of fingers involved in the current event. For example, in a touchend event, this will be the finger that was removed.
  - These lists consist of objects that contain touch information:
    - identifier: a number that uniquely identifies the current finger in the touch session.
    - target: the DOM element that was the target of the action.
    - client/page/screen coordinates: where on the screen the action happened.
    - radius coordinates and rotationAngle: describe the ellipse that approximates finger shape.
- some mobile browsers will select text if a user long touches on the screen, which can be super annoying, disable by:
  - moz-user-select: none;
  - webkit-user-select: none;
  - ms-user-select: none;
  - user-select: none;

### window

#### document

##### document important properties

- readyState: has 3 States; everytime readState changes, a ready state change event fires
  - loading: document still loading
  - interactive: document has loaded and has been parsed, but sub resources (images, css, frames, etc) hasnt loaded
    - loaded === dom.contentLoaded event; useful for running code after all of the initial DOM content has been loaded
  - complete: everything has loaded

#### Request

- A Request instance represents the request piece of a fetch call.
  - important properties
    - method - GET, POST, PUT, DELETE, HEAD
    - url - URL of the request
    - headers - associated Headers object
    - referrer - referrer of the request
    - mode - cors, no-cors, same-origin
    - credentials - should cookies go with the request? omit, same-origin
    - redirect - follow, error, manual
    - integrity - subresource integrity value
    - cache - cache mode (default, reload, no-cache)

#### Response

- properties
  - type - basic, cors
  - url
  - useFinalURL - Boolean for if url is the final URL
  - status - status code (ex: 200, 404, etc.)
  - ok - Boolean for successful response (status in the range 200-299)
  - statusText - status code (ex: OK)
  - headers - Headers object associated with the response.
- methods
  - clone() - Creates a clone of a Response object. VERY USFUL! as you can only read a response body once, so clone it to read it multipel tiems (e.g. to send to multiple places)
  - error() - Returns a new Response object associated with a network error.
  - redirect() - Creates a new response with a different URL.
  - arrayBuffer() - Returns a promise that resolves with an ArrayBuffer.
  - blob() - Returns a promise that resolves with a Blob.
  - formData() - Returns a promise that resolves with a FormData object.
  - json() - Returns a promise that resolves with a JSON object.
  - text() - Returns a promise that resolves with a USVString (text).

#### Headers

- Allows you to perform various actions on HTTP request and response headers. These actions include retrieving, setting, adding to, and removing.

#### localStorage

- localStorage is the same as sessionStorage with the same same-origin rules applied but it is persistent.

#### indexedDB

- IndexedDB is a low-level API for client-side storage of significant amounts of structured data, including files/blobs. This API uses indexes to enable high performance searches of this data.
- background:
  - positives:
    - every major browser supports indexeddb
  - negatives:
    - is async but predates promsies, so its eventbased system is horrid.
      - use [IndexedDB Promised library instead](https://github.com/jakearchibald/idb)
- location: resources > indexedDB
- structure:
  - db: can be multiple per website
    - object store: each db can have multiple object stores (i.e. tables) to store data
      - object stores can only be created via the upgrade funcion when creating the DB
        - you have to bump up the version to modify the object store (e.g. add object stores / create indexes)
        - upgrade version only gets called with the upgradeDb() function
      - values: any data type, each item can have a primary key/one of its values can be set as the primary key
      - transactions: (i.e. CRUD), all CRUD operations must be part of a transaction
        - if a transaction fails for a series of steps/actions, none of the steps/actions are applied and the whole transaction is reverted
        - create a transaction object > use it to return an objectStore > operate CRUD on object store
      - indexes: you can create multiple indexes per object store, which orders (i.e. sorts) the values by a specific property making it faster to look up
- API
  - indexedDb: found on window object
    - .deleteDatabase('dbName')
  - IDBObjectStore: interface for an object store
    - methods: add, clear, delete, get, getAll, getAllKeys, etc.
    - properties: indexNames, keyPath, name, transaction, autoIncrement

#### navigator

- The Navigator interface represents the state and the identity of the user agent. It allows scripts to query it and to register themselves to carry on some activities.

#### Worker

- Web worker: runs separately from the page, isnt visible to the user, cant access the DOM,
  .it intercepts and controls requests made by the browser

#### caches

- updating static cache:
  - create new SW
  - remove old SW
  - when #1 is actived, deleted old cache
  - create new cache
- see cache: dev tools > resources/application > cache storage
- cache names in prod should be auto generated and cache times set to a year a more, when the file changes, you can just upload the new file (with a different name) and that will force an update since the url to the file changes
- be sure the cache names are versioned or auto-generated, e.g. somecache-v1 | somecache-!@#s
- opening a cache returns a response objects
- a response object can only be used once, you will need to call response.clone() to use it more than once

##### methods

- caches.open('createOrOpenACache').then(function(cache){...})
  - create or open a cache-box by name
  - returns a promise of request and response pairs from any secure origin
  - can store fonts, scripts, images, etc. from your origin, and any origin on the web
- cache.put(request, response);
  - store a request response in
- cache.addAll([request1, request2, 'url3', 'url4'])
  - accepts request objects / urls, makes the requests, and stores the results
    - are atomic requests, if any fail, none are added
- cache.match(requestObjectOrUrlString)
  - retrieve something from the cache
  - returns matching response or null
- caches.match(requestObjectOrUrlString)
  - same as cache.match, only searches ALL CACHES starting with the oldest first
  - retrieve response from cache for all matching requests
- caches.delete('cacheName|cacheObject') //always clean your cache
- caches.keys() //get names of all your caches
