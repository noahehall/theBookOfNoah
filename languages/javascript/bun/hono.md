# hono

- Hono is a lightweight ultrafast web framework designed for the edge.
- framework similar to Express, But it runs on CDN Edges and allows you to construct larger applications when combined with middleware
- FYI notes in this file are specific to bun, check the docs for cloudflare/deno/aws/etc
- [bookmark](https://hono.dev/api/hono#fire)

## links

- [landing page](https://hono.dev/top)

### docs

- [AAAA: getting started](https://hono.dev/getting-started/basic)
- [bun](https://hono.dev/getting-started/bun)
- [middleware](https://hono.dev/concepts/middleware)
- [routers](https://hono.dev/concepts/routers)
- [stacks](https://hono.dev/concepts/stacks)
- [web standard](https://hono.dev/concepts/web-standard)

### api

- [Hono object](https://hono.dev/api/hono)

## TLDR

```sh
# read this https://hono.dev/getting-started/basic

# create an app
bunx create-hono my-app

```

## basics

- works with Zod + zod-to-openapi, check the stacks section

### routers

- the core component of hono
- 5 different types

#### RegExpRouter

- supposedely the fastest in JS ecosystem
- the route registration phase can be slightly slow. So, it's not suitable for an environment that initializes with every request.
  - check LinearRouter instead

#### TrieRouter

- not as fast as RegExpRouter, but provides more functionality
- supposedely faster than express router

#### SmartRouter

- examines all your routes and matches them with the best router
- When the application starts, SmartRouter detects the fastest router based on routing and continues to use it.
  - for some will use regexprouter, so its super fast
  - for others it will use one of the others

```ts
// Inside the core of Hono.
readonly defaultRouter: Router = new SmartRouter({
  routers: [new RegExpRouter(), new TrieRouter()],
})
```

#### LinearRouter

- optimized for "one shot" situations. Route registration is significantly faster than with RegExpRouter because it adds the route without compiling strings, using a linear approach.

#### PatternRouter

- the smallest router among Hono's routers; An application using only PatternRouter is under 12KB in size.

### Middleware

- runs before and after handlers
- REQUEST > m1 > m2 > m3 > HANDLERS > m3 > m2 > m1 > RESPONSE
- very express-esque so you should feel at home

```ts
// example middleware to add X-Response-Time header
app.use("*", async (c, next) => {
  const start = Date.now();
  await next();
  const end = Date.now();
  c.res.headers.set("X-Response-Time", `${end - start}`);
});

// hono has prebuilt middleware too
import { basicAuth } from "hono/basic-auth";
app.use(
  "/admin/*",
  basicAuth({
    // <---- bam!
    username: "admin",
    password: "secret",
  })
);
app.get("/admin", (c) => {
  // <---- boom!
  return c.text("Your are authorized!");
});
```

#### Adapters

- dunno the difference between middleware and adapters, but adapters are platform specific middlewares ;)~

```ts
// import { serveStatic } from "hono/cloudflare-workers"; // blah!
import { serveStatic } from "hono/bun"; // bam! check the docs for all the options

const app = new Hono();

app.use("/static/*", serveStatic({ root: "./" }));
app.use("/favicon.ico", serveStatic({ path: "./favicon.ico" }));
app.get("/", (c) => c.text("You can access: /static/hello.txt"));
app.get("*", serveStatic({ path: "./static/fallback.txt" }));
```

### stacks

#### RPC

- allows you to share API specs with little change to your code.
- The client generated by `hc` will read the spec and access the endpoint Type-Safety.
- key components
  - hono api server
  - Zod Validator
  - Zod Validator Middleware
  - `hc` http client

```ts
////////// BASIC process

// build out your api normally
app.get("/hello", (c) => {
  return c.json({
    message: `Hello!`,
  });
});

// then go back and add ZOD validation
app.get(
  "/hello",
  zValidator(
    // <---- validator
    "query",
    z.object({
      name: z.string(),
    })
  ),
  (c) => {
    const { name } = c.req.valid("query"); // bam!
    return c.json({
      message: `Hello! ${name}`,
    });
  }
);

// emit an endpoint specification for public endpoints
const route = app.get(
  "/hello",
  zValidator(
    "query",
    z.object({
      name: z.string(),
    })
  ),
  (c) => {
    const { name } = c.req.valid("query");
    // use jsonT instead of json
    return c.jsonT({
      message: `Hello! ${name}`,
    });
  }
);
export type AppType = typeof route; // <------ dont forget to expore it!

// on the client side you consume AppType as a generic
import { AppType } from "./server";
import { hc } from "hono/client";

const client = hc<AppType>("/api"); // <---- bam!
const res = await client.hello.$get({
  query: {
    name: "Hono",
  },
});
```

### Presets

- abcd

## API

### Hono object

- Hono is the primary object. It will be imported first and used until the end.

```ts
import { Hono } from 'hono'

const app = new Hono()
//... bunch of stuff here

export default app // for Cloudflare Workers or Bun

// instance methods
app.HTTP_METHOD([path,]handler|middleware...)
app.all([path,]handler|middleware...)
app.on(method|method[], path, handler|middleware...)
app.use([path,]middleware)
app.route(path, [app])
app.basePath(path)
app.notFound(handler)
app.onError(err, handler)
app.showRoutes()
app.routerName
app.mount(path, anotherApp)
app.fire()
app.fetch(request, env, event)
app.request(path, options)

```

### examples

```ts
/////////////// basic app
import { Hono } from "hono";

const app = new Hono();

app.get("/", (c) => {
  return c.text("Hello Hono!");
});

export default app;

/////////////// basic tests
import { describe, expect, it } from "bun:test";
import app from ".";

describe("My first test", () => {
  it("Should return 200 Response", async () => {
    const req = new Request("http://localhost/");
    const res = await app.fetch(req);
    expect(res.status).toBe(200);
  });
});

/////////////// basic API
// c is the world, check the docs

// bunch of stuff
app.notFound((c) => {
  return c.text("Custom 404 Message", 404);
});
app.onError((err, c) => {
  console.error(`${err}`);
  return c.text("Custom Error Message", 500);
});
app.post("/posts", (c) => c.text("Created!", 201));
app.delete("/posts/:id", (c) => c.text(`${c.req.param("id")} is deleted!`));
app.get("/posts/:id", (c) => {
  // extract stuff from url params
  const page = c.req.query("page");
  const id = c.req.param("id");

  // set a header
  c.header("X-Message", "Hi!");

  // return raw response
  return new Response("Good morning!");
  // or text
  return c.text(`You want see ${page} of ${id}`);
  // or json
  return c.json({
    ok: true,
    message: "Hello Hono!",
  });
});

// return some html with jsx, make sure the file ends in .tsx
const View = () => {
  return (
    <html>
      <body>
        <h1>Hello Hono!</h1>
      </body>
    </html>
  );
};

app.get("/page", (c) => {
  return c.html(<View />);
});
```
