# TUTS
  - bookmark:
    + [list of all methods](https://github.com/d3/d3/blob/master/API.md)
    + [d3 v4 piechart](https://bl.ocks.org/shimizu/f90651541575f348a129444003a73467)
  - nextup:
    + https://github.com/d3/d3-axis
    + https://github.com/d3/d3-transition#the-life-of-a-transition
    + https://github.com/d3/d3-ease
    + https://github.com/d3/d3-scale-chromatic // color scales
    + https://medium.com/@mbostock/introducing-d3-scale-61980c51545f#.14ptxammq
    + http://chimera.labs.oreilly.com/books/1230000000345/ch07.html
    + http://www.jeromecukier.net/blog/2011/08/11/d3-scales-and-color/
    + https://github.com/d3/d3-color
    + https://github.com/d3/d3-transition
    + https://github.com/d3/d3-selection/blob/master/README.md#local-variables
    + https://github.com/d3/d3-array#bisect
    + https://github.com/d3/d3-time
    + https://github.com/d3/d3-format
    + https://github.com/d3/d3-time-format
    + [text resizing](https://bl.ocks.org/mbostock/1846692)
    + [text resizing](http://stackoverflow.com/questions/20115090/d3-js-auto-font-sizing-based-on-nodes-individual-radius-diameter)
    + [radial stacked bar chart](https://bl.ocks.org/mbostock/6fead6d1378d6df5ae77bb6a719afcb2)
# D3 Links
  - [All d3 Modules API Reference](https://github.com/d3)
# Links
  - [SVG Blur effects](http://www.w3schools.com/svg/svg_fegaussianblur.asp)
  - [SVG Drop Shadows](http://www.w3schools.com/svg/svg_feoffset.asp)
  - [SVG Gradients](http://www.w3schools.com/svg/svg_grad_linear.asp)
	  + http://www.w3schools.com/svg/svg_grad_radial.asp
  - [SVG Examples](http://www.w3schools.com/svg/svg_examples.asp)
# Examples
  - mbstocks d3 in react: http://bl.ocks.org/milroc/d22bbf92231876505e5d
  - [general update patters](http://bl.ocks.org/mbostock/3808218)
  - [simple bar chart](https://bl.ocks.org/shimizu/5eb73aa907d64ee6e5f1d97b922c8801)

# Data visualization
  - data vis: the presentation of data in a graphical/pictoral format
  - visual perception: humans can distinguish differences in the following (pre-attentive) attributes with minimal effort
    1. length
    2. shape
    3. color
  - questions to ask when creating a chart
    1. what type of chart does the data require ?
    2. what type of scale for x domain ?
    3. what type of scale for y domain ?
    4. do what x or y axis require its own scale?
    5. What is required in the legend ?
    6. what kind of interactivity ?

## bar charts
  - visual dimensions:
    1. length/count
    2. color
    3. category
## histogram
  - visual dimensions:
    1. bin size (range of intervals)
    2. length/count
    3. color
## scatterplot
  -  visual dimensions
    1. x & y positions
    2. color
    3. size
## network
  - purpose: how different data sets are related to eachother and between their nodes
  - visual dimensions
    1. node size
    2. node color
    3. ties size
    4. ties color
    5. spatialization
## tables
  - visual dimensions
    1. columns and rows

# SVG
  - svg supports complex shapes,
  - styling via css
  - tag based like html
  - viewport
    + The viewport is the visible section of an SVG. While an SVG can be as wide or as high as we wish, only a certain section of this image can be visible at a time.
    - The viewport is set through height and width attributes within the <svg>.
  - viewbox
    + specify that a given set of graphics stretch to fit a particular container element.
    + These values include four numbers separated by commas or spaces that should generally be set to the bounds of the viewport.
      - If we choose to not define a viewBox the image will not scale to match the bounds set by the viewport.
      - The min values represent from what point within the image the viewBox should start,
        1. min-x:
        2. min-y:
      - The width and height of our SVG establish the visible area (the viewport)
        3. width:
        4. height:
  - preserveAspectRatio, e.g. `preserveAspectRatio=“xMaxYMax meet”`
    + If the SVG viewBox and viewport do not have the same width to height ratio, preserveAspectRatio indicates whether or not to force uniform scaling.
    + align:  directs the viewBox's alignment within the viewport
      - https://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
      - https://www.w3.org/TR/SVG/images/coords/PreserveAspectRatio.svg
    + meetOrSlice: indicates how the aspect ratio is to be preserved.
      - meet: preserves the aspect ratio by scaling the viewBox to fit within the viewport as much as possible.
      - slice: attempts to fill the viewport with the viewBox and will then slice off any part of the image that does not fit inside the viewport after this scaling.
      - none: no preserved aspect ratio and a potentially distorted image.
    + common values
      - `xMinYMax meet`:
        + aligning the bottom left corner of the viewBox to the bottom left corner of the viewport
        + meet is ensuring the image is scaling to fit inside the viewport as much as possible.
      - `xMinYMin meet`:
        +
## basics
  - create a canvas
    ```
      <svg style='background-color:black' height='100' width='100'>
        <text x='0' y='20' fill='red'>
          This is SVG Text
        </text>
      </svg>
    ```

# d3 basics
  - manipulate html documents based on data
  - display data using html, svg, and css
	- uses css like selectors
	- use css/js for styling
	- easy parse data from text, json, html, csv, tsv
	- data binding: retrieve data and bind it to a function
	- has a physics engine
	- comes with click & drag behaviors
## definitions
  - binding data: bind (connect) data to dom nodes
  + take an array of numbers and bind them to an html table, when the array updates the html table updates
  + data: text, json, html, csv, tsv

## quickies
  - most callback functions should accept arguments (d, i, g) => data, index, group, with 'this' being the current node
### utility functions
  - get the max number: `d3.max(array)`
### selecting: all return selections
  - select the first paragraph: `d3.select('p')`
  - select all paragraphs: `d3.selectAll('p')`
  - select a node: `d3.select(this)`
  - select all child paragraphs: `d3.select(this).select('p')`
  - select all previous elements: `d3.selectAll("p").select(() => this.previousElementSibling);`
  - select only the even: `d3.selectAll("tr").filter(":nth-child(even)");`
### changing attributes, properties and styles: all operate on selections
  - update an attribute: ` selection.attr('name'[, value|function])`
  - assign both classes foo and bar to selection: `selection.classed("foo bar", true);`
    + you can pass a function, if its return is truthy, that element is given the class
  - updating style of element: `selection.style(name[, value[, priority]])`
### changing text
  - set the text content: `selection.text([value])`
  - set the inner html: `selection.html([value])`
    + SVG elements and other non-HTML elements do not support the innerHTML property
### Appending|inserting|removing|etc nodes
  - append a new child element: `d3.selectAll("p").append("div");`
  - insert an element before this one: `selection.insert(type, before)`
  - remove elements: `selection.remove()`
  - other functions:
    + sort, order, raise, lower, creator

### Joining Data
  - `selection.data([data[, key]])`
    + returning a new selection that it represents the update selection:
    + defines the enter and exit selections on the returned selection, which can be used to add or remove elements to correspond to the new data.
    + the data is an array of arbitrary values (e.g., numbers or objects), or a function that returns an array of values for each group
    + When data is assigned to an element, it is stored in the property __data__, thus making the data “sticky” and available on re-selection.
    + example 0: general update pattern
      1. Any existing circles (that are descendants of the svg selection) are selected.
      2. These circles are joined to new data, returning the matching circles: the update selection.
      3. These updating circles are given a blue fill.
      4. Any existing circles that do not match new data—the exit selection—are removed.
      5. New circles are appended for any new data that do not match any existing circle: the enter selection.
      6. These entering circles are given a green fill.
      7. A new selection representing the union of entering and updating circles is created.
      8. These entering and updating circles are given a black stroke.
        ```
          var circle = svg.selectAll("circle") // 1
            .data(data) // 2
              .style("fill", "blue"); // 3

          circle.exit().remove(); // 4

          circle.enter().append("circle") // 5
              .style("fill", "green") // 6
            .merge(circle) // 7
              .style("stroke", "black"); // 8
        ```
    + example 1: binding data to tr, and insert the same data in a td
      1. the data function is the identity function: for each table row, it returns the corresponding row from the data matrix.
      2. If a key function is not specified, then the first datum in data is assigned to the first selected element, the second datum to the second selected element, and so on.
         - A key function may be specified to control which datum is assigned to which element, replacing the default join-by-index.
        ```
          var matrix = [
            [11975,  5871, 8916, 2868],
            [ 1951, 10048, 2060, 6171],
            [ 8010, 16145, 8090, 8045],
            [ 1013,   990,  940, 6907]
          ];

          var tr = d3.select("body")
            .append("table")
            .selectAll("tr")
            .data(matrix)
            .enter().append("tr");

          var td = tr.selectAll("td")
            .data(function(d) { return d; })
            .enter().append("td")
            .text(function(d) { return d; });
        ```
    + example 2: binding data utilizing a key function to assign data to a specific element
      1. key function uses the datum d if present, and otherwise falls back to the element’s id property.
        - Since these elements were not previously bound to data, the datum d is null when the key function is evaluated on selected elements, and non-null when the key function is evaluated on the new data.
      ```
        <div id="Ford"></div>
        <div id="Jarrah"></div>
        <div id="Kwon"></div>
        <div id="Locke"></div>
        <div id="Reyes"></div>
        <div id="Shephard"></div>
        var data = [
          {name: "Locke", number: 4},
          {name: "Reyes", number: 8},
          {name: "Ford", number: 15},
          {name: "Jarrah", number: 16},
          {name: "Shephard", number: 31},
          {name: "Kwon", number: 34}
        ];

        d3.selectAll("div")
          .data(data, function(d) { return d ? d.name : this.id; })
            .text(function(d) { return d.number; });
      ```
#### `Selection.enter()`
  - Returns the enter selection: placeholder nodes for each datum that had no corresponding DOM element in the selection. The enter selection is determined by selection.data, and is empty on a selection that is not joined to data.
  - The enter selection is typically used to create “missing” elements corresponding to new data
    ```
      // If the body is initially empty, the below code will create six new DIV elements, append them to the body in-order, and assign their text content as the associated (string-coerced) number:
      var div = d3.select("body")
        .selectAll("div")
        .data([4, 8, 15, 16, 23, 42])
        .enter().append("div")
          .text(function(d) { return d; });
    ```
#### `Selection.exit()`
  - Returns the exit selection: existing DOM elements in the selection for which no new datum was found.
  - The exit selection is typically used to remove “superfluous” elements corresponding to old data.
    ```
      // uses the previous example whose data was .data([4, 8, 15, 16, 23, 42])
      // update the DIV elements created previously with a new array of numbers using a key function
      div = div.data([1, 2, 4, 8, 16, 32], function(d) { return d; });
      // we can append new elements for [1, 2, 32] using the enter selection:
      div.enter().append("div").text(function(d) { return d; });
      // Likewise, to remove the exiting elements [15, 23, 42]:
      div.exit().remove();
      // now the DOM looks like this
      <div>1</div>
      <div>2</div>
      <div>4</div>
      <div>8</div>
      <div>16</div>
      <div>32</div>
    ```
#### `selection.datum([value])`
  - Gets or sets the bound data for each selected element.
  - If a value is specified, sets the element’s bound data to the specified value on all selected elements.
  - Example 0: setting data based on html data attributes
    ```
      // given this set of elements
      <ul id="list">
        <li data-username="shawnbot">Shawn Allen</li>
        <li data-username="mbostock">Mike Bostock</li>
      </ul>
      // this sets the data
      selection.datum(function() { return this.dataset; })
    ```

### listening for events: `selection.on(typenames[, listener[, capture]])`
  - Adds or removes a listener to each selected element for the specified event typenames
  - The typenames is a string event type, such as click, mouseover, or submit; any DOM event type supported by your browser may be used.
    + The type may be optionally followed by a period (.) and a name; the optional name allows multiple callbacks to be registered to receive events of the same type, such as click.foo and click.bar
    + To specify multiple typenames, separate typenames with spaces, such as input change or click.foo click.bar.
  - Listeners always see the latest datum for their element, but the index is a property of the selection and is fixed when the listener is assigned; to update the index, re-assign the listener.
    + If an event listener was previously registered for the same typename on a selected element, the old listener is removed before the new listener is added.
    + To remove a listener, pass null as the listener.
    + To remove all listeners for a given name, pass null as the listener and .foo as the typename, where foo is the name;
    + to remove all listeners with no name, specify . as the typename.
  - An optional capture flag may be specified which corresponds to the W3C useCapture flag: “After initiating capture, all events of the specified type will be dispatched to the registered EventListener before being dispatched to any EventTargets beneath them in the tree.
### trigger/dispatching events: `selection.dispatch(type[, parameters])`
  - Dispatches a custom event of the specified type to each selected element, in order.
  - An optional parameters map may be specified to set additional properties of the event. It may contain the following fields:
    + bubbles - if true, the event is dispatched to ancestors in reverse tree order.
    + cancelable - if true, event.preventDefault is allowed.
    + detail - any custom data associated with the event.
    + If parameters is a function, it is evaluated for each selected element, in order
### other events
  - event, customEvent, mouse, touch, touches

### Control Flow
  - Invokes the specified function for each selected element: `selection.each(function)`
  - `selection.call(function[, arguments…])`
    + Invokes the specified function exactly once, passing in this selection along with any optional arguments
    + example 1: set a bunch of styles in a callback function
    ```
      function name(selection, first, last) {
        selection
            .attr("first-name", first)
            .attr("last-name", last);
      }

      // use like this
      d3.selectAll("div").call(name, "John", "Snow");
    ```
  - check if the selection is empty `selection.empty()`
  - get the first non null node in selection `selection.node()`
  - get the # of elements in selection `selection.size()`

### Local Variables
  -

### scales
  - https://github.com/d3/d3-scale
  - map an input domain (e.g. 0 to 10000) to an output range (e.g. 0 to 100)
    + the input domain can be anything, not necessarily a bunch of numbers
    + the output range should map to the dimensions of the svg viewport
      - input domain: [0, 1000] : is the lowest and highest points in the data
      - output range: [0, 100] : range of possible values commonly used as display values in pixels
  - can represent any visual encoding, e.g. diverging colors, stroke widths, symbol size
  - can be used with any tim eof data, e.g. named categorical data, discrete data, etc.
  - When to use which scale
    + continuous quantitative data:
      1. linear scale
      2. log|power scale (if its super wide)
      3. quantize scale if you need to round continuous data to a fixed set of discrete values
      4. threshold scale if you need arbitrary breaks in continuous data
    + Discrete Ordinal/ordered or Categorical/unordered
      1. ordinal scale: explicit mapping from one set of data to another
      2. band scale : good for bar charts
      3. point scale : good for scatter plots
    + Time Series data:
      1. time scale
    + Population
      1. quantile scale
    +  colors
      1. use sequential scales
      2. use linear scales
    + Always
      0. use the scale that shows the interesting behavior the most clearly
      1. log|power > linear: whenever you need to see the relative differences between sets of data
      2. linear > log|power: whenever the absolute differences are more important
      3. band/point scales: for bar charts and scatterplots
#### Continuous Scales
  + Continuous scales map a continuous, quantitative input domain to a continuous output range.
  + all of them are created in this form:
    ```
      var x = d3.scaleLinear()
        .domain([10, 130])
        .range([0, 960]);
      x(20); // 80
      x(50); // 320
    ```
  + specify input domain: `d3.scaleLinear().domain([ #1, #2 ])`
    - input domain must be numbers
    - sending in 3/more numbers creates piecewise scale
    - Example 0: create a diverging color scale that interpolates between white and red for negative values, and white and green for positive values, say:
      ```
        var color = d3.scaleLinear()
          .domain([-1, 0, 1])
          .range(["red", "white", "green"]);

        color(-0.5); // "rgb(255, 128, 128)"
        color(+0.5); // "rgb(128, 192, 128)"
      ```
  + specify output range: `d3.scaleLinear().range([ el1, e2 ])`
    - output range is an array with 2 /more numbers / strings
  + specify output range while also setting the scale's interpolator to interpolateRound
    - `d3.scaleLinear().rangeRound([ el1, el2 ])`
    - is a short hand for
      ```
        continuous
          .range(range)
          .interpolate(d3.interpolateRound);
      ```
  + enable clamping: if the scale is passed a value outside the domain, the scale may return a value outside the range through extrapolation:
    ```
      var x = d3.scaleLinear()
        .domain([10, 130])
        .range([0, 960])
        .clamp(true);
    ```
  + get domain # from range #: `thisScale.invert(rangeNumber)`;
  + skipped
    - `continuous.interpolate(interpolate)`
    - `continuous.ticks([count])`
    - `continuous.tickFormat([count[, specifier]]) `
    - `continuous.nice([count]) `
    - `continuous.copy() `
  + linear: `d3.scaleLinear()`
    - Constructs a new continuous scale with the unit domain [0, 1], the unit range [0, 1], the default interpolator and clamping disabled.
    - Linear scales are a good default choice for continuous quantitative data because they preserve proportional differences
    - Each range value y can be expressed as a function of the domain value x: y = mx + b.
  + Power: `d3.scalePow().exponent([exponent]) `
    - exponent: ` 0.5 // for square root`
      - `d3.scaleSqrt() ` shorthand for `d3.scalePow().exponent(0.5)`
    - Power scales are similar to linear scales, except an exponential transform is applied to the input domain value before the output range value is computed
    - Each range value y can be expressed as a function of the domain value x: y = mx^k + b, where k is the exponent value
  + Log: `d3.scaleLog().base([10])` //default is 10 for base
    - a logarithmic transform is applied to the input domain value before the output range value is computed
    - The mapping to the range value y can be expressed as a function of the domain value x: y = m log(x) + b.
    - notes
      1. As log(0) = -∞, a log scale domain must be strictly-positive or strictly-negative
      2. the domain must not include or cross zero
  + Identity: `d3.scaleIdentity()`
    - Identity scales are a special case of linear scales where the domain and range are identical
    - These scales are occasionally useful when working with pixel coordinates, say in conjunction with an axis or brush. Identity scales do not support rangeRound, clamp or interpolate.
  + Time: `d3.scaleTime()`, for utc shortcut: `d3.scaleUtc() `
    - Time scales are a variant of linear scales that have a temporal domain:
    - domain values are coerced to dates rather than numbers, and invert likewise returns a date
    - Time scales implement ticks based on calendar intervals, taking the pain out of generating axes for temporal domains.
    - example 0:
      ```
        var x = d3.scaleTime()
          .domain([new Date(2000, 0, 1), new Date(2000, 0, 2)])
          .range([0, 960]);

        // set ticks
        x.ticks(d3.timeMinute.every(15));

        x(new Date(2000, 0, 1,  5)); // 200
        x(new Date(2000, 0, 1, 16)); // 640
        x.invert(200); // Sat Jan 01 2000 05:00:00 GMT-0800 (PST)
        x.invert(640); // Sat Jan 01 2000 16:00:00 GMT-0800 (PST)
      ```
    - tickFormat with time scales:
      ```
        %Y - for year boundaries, such as 2011.
        %B - for month boundaries, such as February.
        %b %d - for week boundaries, such as Feb 06.
        %a %d - for day boundaries, such as Mon 07.
        %I %p - for hour boundaries, such as 01 AM.
        %I:%M - for minute boundaries, such as 01:23.
        :%S - for second boundaries, such as :45.
        .%L - milliseconds for all other times, such as .012.
      ```
#### Sequential scales
  - Sequential scales are similar to continuous scales in that they map a continuous, numeric input domain to a continuous output range.
  - the output range of a sequential scale is fixed by its interpolator and not configurable
  - These scales do not expose invert, range, rangeRound and interpolate methods.
  - skipped:
    + d3.interpolateViridis(t)
    + d3.interpolateInferno(t)
    + d3.interpolateMagma(t)
    + d3.interpolatePlasma(t)
    + d3.interpolateWarm(t)
    + d3.interpolateCool(t)
    + d3.interpolateRainbow(t)
    + d3.interpolateCubehelixDefault(t)
#### Quantize scales: `d3.scaleQuantize()`
  - Quantize scales are similar to linear scales, except they use a discrete rather than continuous range
  - The continuous input domain is divided into uniform segments based on the number of values in (i.e., the cardinality of) the output range
    + its ALL about specifying the number of elements in the output range array
  - [mbostock example](http://bl.ocks.org/mbostock/4060606)
  - `quantize.invertExtent(value)`
    + Returns the extent of values in the domain [x0, x1] for the corresponding value in the range: the inverse of quantize.
#### Quantile scales: `d3.scaleQuantile()`
  - Quantile scales map a sampled input domain to a discrete range.
  - The domain is considered continuous and thus the scale will accept any reasonable input value;
    + however, the domain is specified as a discrete set of sample values.
  - The number of values in (the cardinality of) the output range determines the number of quantiles that will be computed from the domain.
    - example: http://bl.ocks.org/mbostock/8ca036b3505121279daf
  - skipped:
    + `quantile.quantiles()`
#### Threshold scales: `d3.scaleThreshold()`
  - Threshold scales are similar to quantize scales, except they allow you to map arbitrary subsets of the domain to discrete values in the range.
  - The input domain is still continuous, and divided into slices based on a set of threshold values.
    + [example](http://bl.ocks.org/mbostock/3306362)
  - skipped
    + threshold.invertExtent(value)
#### Ordinal scales: `d3.scaleOrdinal()`
  - ordinal scales have a discrete domain and range
    + map a set of named categories to a set of colors
    + determine the horizontal positions of columns in a column chart.
  - takes same configuration as Continuous scales
  - skipped:
    + `ordinal.unknown([value])`
    + `d3.scaleImplicit`
  - Band: `d3.scaleBand()` : SKIPPED ALL OF THIS
    + Band scales are like ordinal scales except the output range is continuous and numeric
    + Discrete output values are automatically computed by the scale by dividing the continuous range into uniform bands.
    + Band scales are typically used for bar charts with an ordinal or categorical dimension.
    - `band.rangeRound([range])`
  - Point: `d3.scalePoint()` : SKIPPED ALL OF THIS
    + Point scales are a variant of band scales with the bandwidth fixed to zero
    + Point scales are typically used for scatterplots with an ordinal or categorical dimension.
  - Category: `var color = d3.scaleOrdinal(d3.schemeCategory10);`
    + These color schemes are designed to work with d3.scaleOrdinal.
    + get more categories from `d3-scale-chromatic`
    + categories: schemeCategory10, schemeCategory20, schemeCategory20b, schemeCategory20c

### axes: `d3.axisTop|Right|Bottom|Left|(scale)`
  - all axes require a scale
  - vertical axis usually require an inverted range, so that 0 is at the bottom left corner, and not the top right corner
    + `someScale.range([ height, 0 ])`
  - skipped
    + `axis.ticks(arguments…)`
    + ` axis.tickArguments([arguments])`
    + `axis.tickValues([values])`
    + `axis.tickFormat([format])`
    + `axis.tickSize([size]) `
    + `axis.tickSizeInner([size]) `
    + `axis.tickSizeOuter([size]) `
    + `axis.tickPadding([padding]) `

### Shapes:
  + https://github.com/d3/d3-shape
#### Arcs `d3.arc()`
  + The arc generator produces a circular or annular sector, as in a pie or donut chart.
  + Constructs a new arc generator with the default settings
  + example 0: both output the same
    ```
      // using an object
      var arc = d3.arc();
      arc({
        innerRadius: 0,
        outerRadius: 100,
        startAngle: 0,
        endAngle: Math.PI / 2
      }); // "M0,-100A100,100,0,0,1,100,0L0,0Z"

      // using constants on the constructor
      var arc = d3.arc()
        .innerRadius(0)
        .outerRadius(100)
        .startAngle(0)
        .endAngle(Math.PI / 2);
      arc(); // "M0,-100A100,100,0,0,1,100,0L0,0Z"
    ```
  + Computes the midpoint [x, y] of the center line of the arc that would be generated by the given arguments. : `arc.centroid(arguments…)`
    - i.e. computes the center of each slice, this method is merely a convenience for positioning labels.
  + `arc.innerRadius([radius])`
  + `arc.outerRadius([radius])`
  + `arc.cornerRadius([radius])`
    - If the corner radius is greater than zero, the corners of the arc are rounded using circles of the given radius.
    - The corner radius may not be larger than (outerRadius - innerRadius) / 2
  + `arc.startAngle([angle])`
  + `arc.endAngle([angle])`
  + `arc.padAngle([angle])`
    - The recommended minimum inner radius when using padding is outerRadius * padAngle / sin(θ), where θ is the angular span of the smallest arc before padding.
  + `arc.padRadius([radius])`
  + `arc.context([context])`
#### `d3.pie()`
  + Constructs a new pie generator with the default settings.
    - The pie generator does not produce a shape directly, but instead computes the necessary angles to represent a tabular dataset as a pie or donut chart; these angles can then be passed to an arc generator.
    - example 0: passing data to `d3.pie()` to generate a pie
      + returns an object for each data point:
        - data - the input datum; the corresponding element in the input data array.
        - value - the numeric value of the arc.
        - index - the zero-based sorted index of the arc.
        - startAngle - the start angle of the arc.
        - endAngle - the end angle of the arc.
        - padAngle - the pad angle of the arc.
        ```
          var data = [1, 1, 2, 3, 5, 8, 13, 21];
          var arcs = d3.pie()(data);
            // The first pair of parens, pie(), constructs a default pie generator.
            // The second, pie()(data), invokes this generator on the dataset, returning an array of objects:
            [
              {"data":  1, "value":  1, "startAngle": 6.050474740247008, "endAngle": 6.166830023713296, "padAngle": 0},
              {"data":  1, "value":  1, "startAngle": 6.166830023713296, "endAngle": 6.283185307179584, "padAngle": 0},
              ... for each element in data
            ]
        ```
  + `pie.value([value])`
    - sets the value accessor to the specified function or number and returns this pie generator.
    - example 0: specifying what datum to use for the pie slices
      ```
        var data = [ // regular array of objects
          {"number":  4, "name": "Locke"},
          {"number":  8, "name": "Reyes"},
          {"number": 15, "name": "Ford"},
          {"number": 16, "name": "Jarrah"},
          {"number": 23, "name": "Shephard"},
          {"number": 42, "name": "Kwon"}
          ];
        var arcs = d3.pie()
          .value(function(d) { return d.number; }) // specify accessor
          (data); //invoke with data

        // alternatively you can pass specific data points
        // but this removes the data binding of the other data attributes
        var arcs = d3.pie()(data.map(function(d) { return d.number; }));
      ```
  + `pie.sort([compare])`
    - If compare is specified, sets the data comparator to the specified function and returns this pie generator.
    - The compare function takes two arguments a and b, each elements from the input data array.
      + If the arc for a should be before the arc for b, then the comparator must return a number less than zero;
      + if the arc for a should be after the arc for b, then the comparator must return a number greater than zero;
      + returning zero means that the relative order of a and b is unspecified.
      + example 0: sorting arcs by their name
        ```
          pie.sort(function(a, b) { return a.name.localeCompare(b.name); });
        ```
  + `pie.sortValues([compare])`
    - If compare is specified, sets the value comparator to the specified function and returns this pie generator.
      + The value comparator is similar to the data comparator, except the two arguments a and b are values derived from the input data array using the value accessor, not the data elements.
      + example 0: sort in ascending order
        ```
          pie.sortValues(function(a, b) { return a - b; });
        ```
  + `pie.startAngle([angle])`
  + `pie.endAngle([angle])`
  + `pie.padAngle([angle]) `

#### `d3.line()` skipped
#### `d3.area()` skipped
#### `d3.curveBasis(context)` skipped
#### `d3.symbol()` skipped
#### `d3.stack()` skipped

### changing
  - change text of an element: `d3.select('p').text('some text')`
    + you can insert html elements
  - change the style of an element: `d3.select('#piechart').style('color', 'red');`
  - change the style of the second element: `d3.select('#piechart .item:nth-child(2n)').style('color', 'red');`
  - change the style of every second element: `d3.selectAll('#piechart .item:nth-child(2n)').style('color', 'red');`
  - change the style of every odd element: `d3.selectAll('#piechart .item:nth-child(odd)').style('color', 'red');`
    + nth-child(2n+1)
  - change the class name of an element: `d3.select('#piechart .unordered').classed('items', true);`
    + this adds the value to the existing classes of the element
    + set to false to remove
  - change specific attribute: `d3.select('h1').attr('class', 'my-new-class')`;
    + this replaces whatever value it had before
  - modify properties not addressable via style|attr functions
    + form field's text value
    + checkbox's check value
    + `selection.property(name[, value])`
### adding
  - append a div with text: `d3.select('p').append('div').html('some text')`
  - insert (append) a li with text: `d3.select('#piechart .unordered').insert('li').html('new item inserted');`
  - insert a li with text as the third item: `d3.select('#piechart .unordered').insert('li', ':nth-child(3n)').html('new item inserted');`
### removing
  - remove a specific element: `d3.select('#some-element').remove()`
  - remove a the third element: `d3.select('.items:nth-child(3n)').remove()`
### binding data
  - the following only modify EXISTING DOM NODES,
    + if the dom nodes dont exist, nothing happens
    + if only some of the dom nodes exist, only those are updated
      - insert the value of each item in an array into existing DOM nodes
        ```
          d3.selectAll(`#${this.props.id} .array .item`) // select items
            .data(this.props.data.array) // bind data
            .text((d) => d); // map array#index to dom-node#index
        ```
      - use the value of each item in array to set the style of each element
        ```
          d3.selectAll(`#${this.props.id} .array .item`)
            .data(this.props.data.array)
            .style('font-size', (d) => `${d}px`);
        ```
  - add new DOM nodes as required by data
    ```
      // bind data to element, and modify existing elements
      const arrayItems = d3.select(`#${this.props.id} .array`)
        .selectAll('.item')
        .data(this.props.data.array)
        .text((d) => d)
        .style('font-size', (d) => `${d}px`);
      // add additional dom nodes for items in data, and modify new elements
      arrayItems
        .enter()
        .append('li')
        .text((d) => d)
        .style('font-size', (d) => `${d}px`);
      // remove extra dom nodes, if any
      arrayItems
        .exit()
        .remove();
    ```
## broad steps
	- css
		+ set your axis path & line
			```
        fill:none;
  			stroke: color;
  			stroke-width: 1;
  			shape-rendering: cripsEdges;
      ```
	- bar chart
    1. define your margins
		2. define your color scale
		3. grab your chart placeholder and append an svg element
		4. inside the svg element append a group
		5. grab your data
		6. format your data
		7. setup your scales
		8. pass your data to ordinal/linear/etc scales and define the range
		9. setup your bars
	- line chart
		1. define your margins
		2. define your scales
		3. define your axises
		4. define your line
		5. add the svg canvas
		6. grab the data from csv
		7. pass your data through the scales
		8. add the line to the svg
		9. add your axises to the svg
## boilerplate sections {
  - canvas margins:
		+ var margin={top:N, right:N, bottm:N, left:N}
		  - add margins around the actual canvas
  - canvas dimensions:
	  + var width = 600 - margin.left - margin right
	  + var height = 600 - margin.top - margin.bottom
			- the actual dimensions of the canvas (and thus the graph)
## d3 requests:
  - use the following methods to request data
  ```
		.text()
		.json()
		.xml()
		.html()
		.csv()
		.tsv()
  ```
    + e.g.
      ```
    		d3.csv("path/to/csv.csv", function(error,data){
    			data.forEach(function(d){
    				do stuff;
    			})
    		})
      ```
## adding a svg canvas
  ```
		var svg = d3.select('somediv')
			.append('svg')
				.attr({
					'width':width + margin.left + margin.right,
					'height':height + margin.top + margon.bottom
				})
			.append('g')
				.attr({
					'transform': "translate(" + margin.left + "," + margin.top + ")")
				})
  ```


# d3 scales
	- allow you to fit your data into the canvas no matter how many data points
	- allow you to map an input domain to an output range
		+ thus you can be sure your input domain(data) will always fit your output range(graph) succinctly based on the dimensions of the canvas
  - definitions
		+ domain: all possible input values that need to be mapped to the range
		+ range: specifies the range of the canvas, and the order in which the data should be laid out
			- range([height, 0])
        + place the larger values at top of the screen and the lower values at the bottom of the screen
## scale types
	- quantitative scales: for continuous input domains,
		+ numbers, un ordered lists,
	- ordinal scales: for discrete input domains, eg.. names/categories
    + ordered lists
      - the order of the information is relevant
      - this is how you add unlimited values and allow them to fit inside any size canvas
  - time scales: for time domains
### ordinal scales: good for categories
	- xScale = d3.scale.ordinal(x)
    + returns a new ordinal scale with an empty domain and empty range
		+ x = input domain, will return the corresponding value in the output range
		 - e.g. xScale(i)
	  - xScale.domain([your values])
      + the first element in values is mapped to the first element in the output range
      + the domain values are stored as an associated array mapping value to index
			+ to retrieve a value, you send in an index, and you receive its value
		- xScale.range([your values])
			sets the output range to the specified array of values
			the first element in the domain, is mapped to the first element in values
			you can instead 'use' rangePoints or rangeBands
		.rangePoints([min,max],padding)
			interval = min & max of the output range, maps the domain to equally in this range
			padding = set it from 0 to 1, to offset the first and last bars from the edges
		.rangeRoundPoints([min, max], padding)
			interval = see above
			padding = see above
			the difference is that the output range will be integers, and not decimals
		.rangeBands([min,max],padding, outerpadding)
			interval = see above
			padding = space between bars
			outer padding = space between outer bars and chart
		.rangeRoundBands([min,max], padding, outer padding)
			everything is same as above
			only it ensure the intervals are integers and not decimals

		xScale.domain() returns the input domain
		yScale.range() returns the output range

	color categories
		category10() = 10 colors
		category20() = 20 colors
		category20b()
		category20c()
		e.g.
			var colors = d3.scale.category10();


	//linear scales: good for continuous numbers
	yScale = d3.scale.linear(x)
		give a value x in the input domain, returns the corresponding value in the output range
			e.g. yScale(x) : 'use' it like a function to find its place in the scale
		.domain([numbers])
			pass in all of your data points, 2 or more numbers
		.range([values])
			maps the input domain to this output range

	//send your scales to the axis command, to display the axis on the chart
	xAxis = d3.svg.axis()
		creates and returns an empty axis
		xAxis(xScale)
			sets the scale and returns the axis
		.orient('type')
			type = top, bottom, left, right
		.ticks([arguments])
			linear scale: specify a number, e.g. 20
		.tickValues([val1, val2, valX])
			gives a value to each tick

	        /**
         *tick formats
         *"top" - horizontal axis with ticks above the domain path
         *"bottom" - horizontal axis with ticks below the domain path
         *"left" - vertical axis with ticks to the left of the domain path
         *"right" - vertical axis with ticks to the right of the domain path
         */
}

d3 time {
	var parseDate = d3.time.format("your-format-here").parse;
		format("%Y-%m-%d %H:%M:%S")
			generic MySQL ‘YYYY-MM-DD HH:MM:SS’ TIMESTAMP


	var data.someDate = parseDate(data.someData);

	parseDate is now a function base on d3.time
	you can pass data to the function, and it will be formatted so that d3 can recognize it
	formats
		%a - abbreviated weekday name.
		%A - full weekday name.
		%b - abbreviated month name.
		%B - full month name.
		%c - date and time, as “%a %b %e %H:%M:%S %Y”.
		%d - zero-padded day of the month as a decimal number [01,31].
		%e - space-padded day of the month as a decimal number [ 1,31].
		%H - hour (24-hour clock) as a decimal number [00,23].
		%I - hour (12-hour clock) as a decimal number [01,12].
		%j - day of the year as a decimal number [001,366].
		%m - month as a decimal number [01,12].
		%M - minute as a decimal number [00,59].
		%p - either AM or PM.
		%S - second as a decimal number [00,61].
		%U - week number of the year (Sunday as the first day of the week) as a decimal number [00,53].
		%w - weekday as a decimal number [0(Sunday),6].
		%W - week number of the year (Monday as the first day of the week) as a decimal number [00,53].
		%x - date, as “%m/%d/%y”.
		%X - time, as “%H:%M:%S”.
		%y - year without century as a decimal number [00,99].
		%Y - year with century as a decimal number.
		%Z - time zone offset, such as “-0700”.
		There is also a a literal “%” character that can be presented by using double % signs.
}

d3 axis {
	https://github.com/mbostock/d3/wiki/SVG-Axes
	d3.svg.axis().scale(yourScale)
		.orient('blah')
			top/bottom/left/right
			where to place the tick marks relevant to the axis?
		.ticks(N)
			# of ticks
			or a function
		.tickValues(n1,n2,etc)
			specify specific values for the tick
		.tickSize(inner, outer)
		.innerTickSize(size)
			specify only the inner tick size
		.outerTickSize(size)
			specify only the outer tickSize
		.tickPadding(size)
			defaults to 3px
		.tickFormat(format)

 	displays reference lines for scales automatically
}

d3 line {
	d3.svg.line()
		.x(function(d){return xScale(d.xvalue)})
			//set the x value for the current data point
		.y(function(d){return yScale(d.yvalue)})
			//set the y value for the current data point
		.interpolate('blah')
			linear - piecewise linear segments, as in a polyline.
			linear-closed - close the linear segments to form a polygon.
			step - alternate between horizontal and vertical segments, as in a step function.
			step-before - alternate between vertical and horizontal segments, as in a step function.
			step-after - alternate between horizontal and vertical segments, as in a step function.
			basis - a B-spline, with control point duplication on the ends.
			basis-open - an open B-spline; may not intersect the start or end.
			basis-closed - a closed B-spline, as in a loop.
			bundle - equivalent to basis, except the tension parameter is used to straighten the spline.
			cardinal - a Cardinal spline, with control point duplication on the ends.
			cardinal-open - an open Cardinal spline; may not intersect the start or end, but will intersect other control points.
			cardinal-closed - a closed Cardinal spline, as in a loop.
			monotone - cubic interpolation that preserves monotonicity in y.
}

d3 arcs (half circle charts){

}
d3 functions{
	d3.extent(values)
		returns an array with the lowest and highest values
		d3.extent(data, function (d){return d.somedata})

	d3.max(values)
		returns the largest value
			d3.max(data, function(d){ return d.somedata})
	d3.format
		https://github.com/mbostock/d3/wiki/Formatting#d3_format
}
selectors {
	d3.select(selector)
		selects the first element that matches the selector string

	d3.selectAll(selector)
		selects all elements thta matches the selector

	selects: regular css
		#someid .childclasses
		.class:nth-child(5) #select the 5th element
			:nth-child(odd)
				even
				n+3
				3n
}

commands basic {

	inserting new things
		.text('insert this')
			inserts this into the selected element

		.html('<b>random bold element</b>')
			inserts html into the selected element

		.append('div')
			inserts a new element as the last child of the selected element

		.insert('div' ':nth-child(3)');
			insert a new div as the 3rd child in the selected element

	removing items
		.remove()
			remove the selected element

	modifying items
		.attr('class', 'value')
			provide an attribute and a value
			this will replace the current value with the new value

		.classed('newclass', 'true')
			adds  a new class, without removing the current class
				true = add the class
				false = remove the class

		.classed({
			'class1': true
			'class2': false
		})
			send in multipel classes to turn on/off

	css
		.style({
			'key': 'value'
		})
			provide css key value pairs,
			can be used to automate things

}

commands data {
	d3.selectAll('.items.')
		.data([blah1,blah2])

			takes an array of elements,
			and applies the first item in the array to the first item selected
			and the second item in the array to the second item selected

		.data(myVar)
		.style('background', myStyles[0])
			can hold the array as a variable and send the var in
			then use specific items in the array


		.data(myStyles)
		.style('background', function(d) {
			return d[0]
			[or]
			return d
		})
			 d = myStyles, 0 takes the first element
			 if you dont pass it an index, each item in the myStyles
			 will be used to style the matchign index in the selection

		.data(myStyles)
		.style({
			'color':'white',
			'background':function(d){
				return d;
			}
		})
			change multiple values to the style method
			and still use the myStyles array

		.data(myStyles)
		.style({
			'color':'white',
			'background':function(d){
				return d.color;
			},
			'width':function(d){
				return d.width + 'px';
			}
		})
			myStyes = an object
			you can specify which property of the object to use


}

commands subselector {
	use the .enter() command to create a placeholder
	for selecting subselections of other selections

	d3.selectAll('#main') #select id main
		.selectAll('div') #create a placeholder element
		.data(myStyles) #bind .data to the placeholder element and pass in your object styles
		.enter() #eneter the placeholder element
		.append('div') #replace the placeholder with the actual element
		.classed('item', true) #toggle the class item to true
		.text(function(d){ #add d.name property as the text
			return d.name;
		})
		.style({
			'color':'white',
			'background':function(d){
				return d.color; #add d.color style to the text color
			},
			'width':function(d){
				return d.width +'px'; #add d.width as the width
			}

		})
}


d3 events {
	'use' the .on method
	.on('mouseover',function(d){
		d3.select(this)
			.style('opacity',0.5);
	})
	.on('mouseout',function(d){
		d3.select(this)
			.style('opacity',1);
	})
}

d3 transitions {
 review: http://www.lynda.com/D3js-tutorials/Using-transitions-animations/162449/185065-4.html
	.transition()
	.delay(500) //in milliseconds
	.delay(function(d,i){
		return i*20
	})
	.duration(800) //in milliseconds
	.ease('elastic')

}


d3 layouts {
	https://github.com/mbostock/d3/wiki/layouts

	e.g. pie charts, bar charts, etc.
	provides utilities to convert your data into a layout
}

d3 catagorical colors {
	utility function that provides base colors for your charts

	https://github.com/mbostock/d3/wiki/Ordinal-Scales#categorical-colors
}


transitions {

	ease types
		*linear
		*quad
		*cubic
		*sin
		*exp
		*circle
		*elastic
		*back
		*bounce

}

d3 lines {

	interpolate options
		*linear - piecewise linear segments, as in a polyline.
		*linear-closed - close the linear segments to form a polygon.
		*step-before - alternate between vertical and horizontal segments, as in a step function.
		*step-after - alternate between horizontal and vertical segments, as in a step function.
		*basis - a B-spline, with control point duplication on the ends.
		*basis-open - an open B-spline; may not intersect the start or end.
		*basis-closed - a closed B-spline, as in a loop.
		*bundle - equivalent to basis, except the tension parameter is used to straighten the spline.
		*cardinal - a Cardinal spline, with control point duplication on the ends.
		*cardinal-open - an open Cardinal spline; may not intersect the start or end, but will intersect other control points.
		*cardinal-closed - a closed Cardinal spline, as in a loop.
		*monotone - cubic interpolation that preserves monotonicity in y.

}

svg<?php

background {
	SVG: scalable vector graphics
		used to define vector graphics for the web, including xml
		every element and attribute in svg can be animated

}

structure {
	all attributes can be set by css unless otherwise noted

	reference: http://www.w3schools.com/svg/svg_reference.asp

	<svg> blah </svg>
		container for SVG elements
		width="#" width of container
		height="#" height of container

	<g> </g>
		container of other elements


	shapes
		text:
			<text> blah </text>
				x="#"
				y="#"
				fill="color"
				transform="blah"

				text: with tspan elements to put text on different lines
					<text x="#" y="#" fill="color">
						<tspan x="#" y="#"> hello </tspan>
						<tspan x="#" y="#"> buhby </tspan>
					</text>

				text: as link with an A element
					<svg height="30" width="200" xmlns:xlink="http://www.w3.org/1999/xlink">
					  <a xlink:href="http://www.w3schools.com/svg/" target="_blank">
					    <text x="0" y="15" fill="red">I love SVG!</text>
					  </a>
					</svg>

		lines:
			<line />
				x1="#" start of line on x axis
				x2="#" end of line on x axis
				y1="#" start of line on y axis
				y2="#" end of line on y axis

		rectangle:
			<rect />
				width="#"
				height="#"
				x="#" positive moves to the right
				y="#" positive moves down
				ry="#" round the radius of corners
				rx="#" round the radius of corners

		circle:
			<circle />
				cx="#" center of circle on x
				cy="#" center of circle on y
				r="#" radius of circle

		ellipse: like a circle but has different radius for x and y
			<ellipse />
				cx="#"
				cy="#"
				rx="#" horizontal radius
				ry="#" vertical radius

		polygon: poly = many, gon = angles, e.g. a triangle
			<polygon />
				points="#,# #,# #,# etc."
					#,# = x & y corrdinate of each corner of the polygon

		polyline: any shape that consists of only straight lines
			<polyline />
				points="#,# #,# #,# etc"

		path: define a path, i.e a drawing
			<path />
				d="M150 0 L75 200 L225 200 Z"
					the first point opens the path
					the last letter Z closes the path
				M = move to
				L = line to
				H = horizontal line to
				V = vertical line to
				C - curve to
				S = smooth to
				Q = quadratic bezier curve
				T - smooth quadratic bezier curve to
				A = elliptical arc
				Z = close path
					capital letters = absolutely positioned
					lower case letters = relatively positioned



	common atributes
		stroke="color" color of line, text, or outline of an element
		stroke-width="#" thickness of line, text, or outline of an element
		stroke-linecap="blah" different types of endings to an open path
			butt, round, square
		stroke-dasharray="#,#,#,#,etc" created dashed lines


		fill="color" color of shape
		fill-rule="blah"
			nonzero, evenodd


}


SVG filters {
	<feBlend> - filter for combining images
	<feColorMatrix> - filter for color transforms
	<feComponentTransfer>
	<feComposite>
	<feConvolveMatrix>
	<feDiffuseLighting>
	<feDisplacementMap>
	<feFlood>
	<feGaussianBlur>
	<feImage>
	<feMerge>
	<feMorphology>
	<feOffset> - filter for drop shadows
	<feSpecularLighting>
	<feTile>
	<feTurbulence>
	<feDistantLight> - filter for lighting
	<fePointLight> - filter for lighting
	<feSpotLight> - filter for lighting
}
